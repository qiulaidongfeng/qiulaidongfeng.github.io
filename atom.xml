<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on 秋来冬风的博客</title>
    <link>https://qiulaidongfeng.github.io/</link>
    <description>Recent content in Home on 秋来冬风的博客</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <managingEditor>秋来冬风</managingEditor>
    <webMaster>秋来冬风</webMaster>
    <lastBuildDate>Sat, 31 May 2025 20:57:51 +0800</lastBuildDate>
    <atom:link href="https://qiulaidongfeng.github.io/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go1.25值得关注的</title>
      <link>https://qiulaidongfeng.github.io/zh-cn/go1.25%E5%80%BC%E5%BE%97%E5%85%B3%E6%B3%A8%E7%9A%84/</link>
      <pubDate>Sat, 31 May 2025 20:57:51 +0800</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/zh-cn/go1.25%E5%80%BC%E5%BE%97%E5%85%B3%E6%B3%A8%E7%9A%84/</guid>
      <description>&lt;p&gt;go1.25开发周期已经进入发布冻结，一般情况不再会有新功能，目前笔者认为有以下值得关注的：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;GOMAXPROCS现在会考虑运行在容器时的CPU限制，这在Go程序运行于Kubernetes等容器时非常有用。&lt;/li&gt;&#xA;&lt;li&gt;现在有一个新的垃圾收集器作为实验，在构建时设置环境变量GOEXPERIMENT=greenteagc启用，这在某些场景下提高了性能。&lt;/li&gt;&#xA;&lt;li&gt;现在对于panic后recover再panic的value，不会重复打印value，这避免了测试时panic最终输出包括重复内容。&lt;/li&gt;&#xA;&lt;li&gt;实验性包testing/synctest已经结束实验转正，像其他标准库的包一样按照go1兼容性承诺保证向后兼容，它为测试并发代码提供了支持。&lt;/li&gt;&#xA;&lt;li&gt;编译器现在使用DWARF version 5生成调试信息，这减少了编译生成二进制文件的大小。&lt;/li&gt;&#xA;&lt;li&gt;net/http包增加了防范跨站点伪造攻击（CSRF）的API。&lt;/li&gt;&#xA;&lt;li&gt;构建时设置环境变量GOEXPERIMENT=jsonv2，可以体验正在使用的json包的v2版本。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>我使用Cloudflare免费计划的经验</title>
      <link>https://qiulaidongfeng.github.io/zh-cn/%E6%88%91%E4%BD%BF%E7%94%A8cloudflare%E5%85%8D%E8%B4%B9%E8%AE%A1%E5%88%92%E7%9A%84%E7%BB%8F%E9%AA%8C/</link>
      <pubDate>Mon, 12 May 2025 11:28:49 +0800</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/zh-cn/%E6%88%91%E4%BD%BF%E7%94%A8cloudflare%E5%85%8D%E8%B4%B9%E8%AE%A1%E5%88%92%E7%9A%84%E7%BB%8F%E9%AA%8C/</guid>
      <description>&lt;h2 id=&#34;cloudflare简介&#34;&gt;Cloudflare简介&lt;/h2&gt;&#xA;&lt;p&gt;Cloudflare是一家2009年成立于美国的企业，初衷是保护网络安全，目前在 330 多个城市拥有数据中心，与大约 95% 的全球互联网用户距离仅约 50 毫秒，凭借 388 Tbps 的网络容量，成功缓解了一些有史以来最大规模的 DDoS 攻击。&lt;/p&gt;&#xA;&lt;p&gt;根据官网：&#xA;Cloudflare的使命是帮助构建更好的互联网。我们认为每个网站和应用都应当可以免费获取基础的安全与性能服务。&lt;/p&gt;&#xA;&lt;p&gt;Cloudflare保护网站时的工作原理如图：&#xA;&lt;img src=&#34;https://qiulaidongfeng.github.io/images/cloudflare.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;用户的请求先发到Cloudflare在来到网站自己的服务器，记住这一点，这在后面很重要。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么选择cloudflare&#34;&gt;为什么选择Cloudflare&lt;/h2&gt;&#xA;&lt;p&gt;Cloudflare定价里有四种计划，其中免费计划虽然不要钱，但也有这些很值得的，对学习建网站很有用的：&lt;/p&gt;&#xA;&lt;h3 id=&#34;安全&#34;&gt;安全&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;不修改服务器支持后量子密钥封装&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;因为量子计算机擅长破解当今普遍使用的RSA(利用大整数因式分解的数学难题)等现有密钥封装使用的公钥算法，导致传统公钥加密体系彻底失效，导致现在的tls在未来不安全。&lt;/strong&gt; 研究应对这种情况的称为后量子密码学（PQC）。&lt;/p&gt;&#xA;&lt;p&gt;尽管目前的量子计算机还未发展到这个程度，但业内预测离这个时候可能只有十到二十年，迁移目前使用的算法到能抵抗量子计算机的算法是一个长期工作，参考tls1.2迁移到tls1.3，从相关标准RFC 8446在2018年8月发布到现在已经过去了快7年，但完全替代tls1.2仍需数年。&lt;/p&gt;&#xA;&lt;p&gt;2024年8月13日，美国国家标准与技术研究所（NIST）正式发布了后量子密码学的三项新标准，其中的FIPS 203 Module-Lattice-Based Key-Encapsulation Mechanism Standar(基于模块格的密钥封装机制标准)，&lt;strong&gt;简称ML-KEM，利用数学难题Module Learning With Errors（模格上带错误学习问题）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiulaidongfeng.github.io/images/MLWE.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以替代RSA等旧的算法，X25519MLKEM768是目前将其应用在tls的混合密钥交换算法，go语言已经在2025年2月发布的go1.24标准库中实现了，并默认在tls连接启用，所以这项功能对我不太有用，不过对使用其他编程语言的人可能是有用的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;免费不限量的DDoS防护&lt;/p&gt;&#xA;&lt;p&gt;DDoS攻击通过大量非法请求占用目标系统的资源（如带宽、内存、CPU 等），导致目标无法正常为合法用户提供服务。&lt;/p&gt;&#xA;&lt;p&gt;目前的DDoS防护市场常见的一些产品，高防IP价格根据防护的峰值攻击速率，在数万至上百万一年。高防服务器的最低价格稍低，有些一年几千块的。&lt;/p&gt;&#xA;&lt;p&gt;根据Cloudflare的博客，&#xA;&lt;strong&gt;Cloudflare曾在2022年6月为一个使用免费计划的客户网站自动缓解了当时有史以来最大规模的 HTTPS DDoS 攻击（在不到 30 秒内，产生了超过 2.12 亿次 HTTPS 攻击请求）。&lt;/strong&gt;&#xA;&lt;strong&gt;无论您使用何种Cloudflare计划(免费、专业、商业或企业),我们都不会让您离开，也不会让您因为攻击的规模而需要向我们支付更多费用。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;根据我的实测，确实是有防护的效果，值得使用。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;访问速率控制&lt;/p&gt;&#xA;&lt;p&gt;对于HTTPS Flood攻击，它是一种DDoS攻击，通过发送大量的HTTPS请求达到攻击目的，处理HTTPS请求需要更多的服务器资源用于加解密。&lt;/p&gt;&#xA;&lt;p&gt;虽然这不用访问速率控制也能被上述免费DDoS防护缓解，但设置访问速率控制是个更有效的做法，&lt;strong&gt;因为检测出是此类攻击到做出反应需要时间和有未检测出的可能，但访问速率控制不会&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;更重要的是，这节省了服务器资源，因为服务器不用自行消耗资源实现此类功能。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;恶意流量过滤&lt;/p&gt;&#xA;&lt;p&gt;Cloudflare提供了Under Attack 模式用来在遭遇DDoS攻击时，让所有访问先进行一个大约5秒的验证，但也可以始终开启，&lt;strong&gt;这将拦截从自动化脚本或恶意机器人来的恶意流量，确保是为真实用户提供服务。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;免费获取IP属地&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;在用户进行登录等操作时，验证IP属地是否在两次登录时一致是一种很有用的账号防盗检测手段。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;目前要获取IP数据，这方面的数据库由商业的获取的信息多，但比较贵，也有免费的，但信息较少。&lt;/p&gt;&#xA;&lt;p&gt;使用Cloudflare可免费获得用户IP属地信息，包括国家或地区，省份或行政区名，城市和经纬度，足够进行账号防盗检测。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;性能&#34;&gt;性能&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;支持http3但不修改服务器&lt;/p&gt;&#xA;&lt;p&gt;http3是http协议的最新版本，传输层改用QUIC（快速UDP网络连接）协议，因为内置tls1.3握手数据一起发送，&lt;strong&gt;首次连接仅需1个RTT&lt;/strong&gt;（RTT是往返时间，指数据发过去再发回来的用时），比http2首次连接需要2-3个RTT更少，同时因为不使用TCP协议，避免了队头阻塞（&lt;strong&gt;前面的数据包丢了要等重新传好再发后面的数据包&lt;/strong&gt;），改善了网络差时的传输延迟等，因为对既往问题的改进，加快了网页加载速度。&lt;/p&gt;&#xA;&lt;p&gt;因为主流编程语言的标准库中并没有提供对QUIC和http3的支持，例如go语言写的程序目前要支持http3,需使用开源库 github.com/quic-go/quic-go/http3 , 它的API用法高度兼容标准库，&lt;strong&gt;改一个函数调用即可支持http3&lt;/strong&gt;，同时能在客户端不支持http3时自动回退到http2，尽管这种办法有各种优点，但使用Cloudflare，&lt;strong&gt;一行代码都不用改即可支持http3&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于我</title>
      <link>https://qiulaidongfeng.github.io/about/</link>
      <pubDate>Sat, 03 May 2025 00:00:00 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/about/</guid>
      <description>&lt;h1 class=&#34;text-center&#34;&gt;关于我&lt;/h1&gt;&#xA;&lt;p&gt;简介：一名Go语言程序员，软件设计师，我给Go语言贡献过很多代码，推动了多项Go语言的提案前进，是go-assigness组成员，有Go语言的may-start-trybots权限.&lt;/p&gt;&#xA;&lt;p&gt;我会go语言和gin框架、mysql、redis、mongodb数据库、jQuery、Bootstrap、gui工具包fyne、hexo和hugo搭建博客、word,excel,ppt。&lt;/p&gt;&#xA;&lt;p&gt;我自学两个月通过了人社部和工信部组织的的 全国计算机技术与软件专业技术资格(水平)考试 ———— 中级 软件设计师 大约百分之七八十多的考试者通不过这项考试。&lt;/p&gt;&#xA;&lt;p&gt;我有全国计算机等级考试 三级证 信息安全技术。&lt;/p&gt;&#xA;&lt;p&gt;我最擅长web后端，其次的做网页和APP，还有做微信公众号自动回复机器人。&lt;/p&gt;&#xA;&lt;p&gt;我懂编译原理，这是我自己设计的编程语言&lt;a href=&#34;https://gitee.com/u-language/u-language&#34; target=&#34;_blank&#34;&gt;u-language&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;我会做网站，这是我做过四个的网站。全部接入了cloudflare免费计划提供的网络安全和网络优化服务。&lt;/p&gt;&#xA;&lt;ul class=&#34;list-group&#34;&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;&lt;a href=&#34;https://qiulaidongfeng.ip-ddns.com/&#34; target=&#34;_blank&#34;&gt;无记名投票&lt;/a&gt;&amp;nbsp;&lt;a href=&#34;https://gitee.com/qiulaidongfeng/nonamevote&#34; target=&#34;_blank&#34;&gt;源代码地址&lt;/a&gt;&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;&lt;a href=&#34;https://chat.qiulaidongfeng.ip-ddns.com/&#34; target=&#34;_blank&#34;&gt;聊天室&lt;/a&gt;&amp;nbsp;&lt;a href=&#34;https://qiulaidongfeng.github.io/zh-cn/用redis构建聊天室/&#34; target=&#34;_blank&#34;&gt;设计方案：用redis构建聊天室&lt;/a&gt;&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;&lt;a href=&#34;https://encrypt.qiulaidongfeng.ip-ddns.com/&#34;&gt;加解密网站&lt;/a&gt;&amp;nbsp;&lt;a href=&#34;https://gitee.com/qiulaidongfeng/myweb/blob/master/wasm/index.html&#34; target=&#34;_blank&#34;&gt;源代码地址&lt;/a&gt;&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;&lt;a href=&#34;https://qiulaidongfeng.github.io/&#34;&gt;我的博客&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;我写的一些开源的APP&lt;/p&gt;&#xA;&lt;ul class=&#34;list-group&#34;&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;&lt;a href=&#34;https://gitee.com/qiulaidongfeng/fynedemo/tree/master/encrypt&#34; target=&#34;_blank&#34;&gt;加解密软件&lt;/a&gt;&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;&lt;a href=&#34;https://gitee.com/qiulaidongfeng/fynedemo/tree/master/randword&#34; target=&#34;_blank&#34;&gt;随机选单词软件&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;以下是一些我给Go语言贡献的代码处理的事&lt;/p&gt;&#xA;&lt;ul class=&#34;list-group&#34;&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;优化reflect.Value.IsZero对于数组类型和结构体类型，性能优化幅度最高达95%以上&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;添加archive/tar.FileInfoNames接口，用来覆盖依赖于系统的Uname/Gname查找&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;消除all.bat在构建工具链后测试的低CPU占用&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;添加迭代相关方法到reflect包，支持反射进行迭代操作&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt; 给go env命令添加-changed flag，支持显示环境变量非默认值&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;修复os/exec.Cmd无法在windows运行不带扩展名的命令&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;给模板添加支持迭代整数和range-over-func&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;强制执行最低引导工具链要求&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;给hash/maphash包添加通用哈希函数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;我给go语言的所有提交记录可以在以下链接看到&lt;/p&gt;&#xA;&lt;ul class=&#34;list-group&#34;&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;&lt;a href=&#34;https://github.com/golang/go/commits/master/?author=qiulaidongfeng&#34; target=&#34;_blank&#34;&gt;https://github.com/golang/go/commits/master/?author=qiulaidongfeng&lt;/a&gt;&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;&lt;a href=&#34;https://github.com/golang/tools/commits/master/?author=qiulaidongfeng&#34; target=&#34;_blank&#34;&gt;https://github.com/golang/tools/commits/master/?author=qiulaidongfeng&lt;/a&gt;&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;&lt;a href=&#34;https://github.com/golang/build/commits/master/?author=qiulaidongfeng&#34; target=&#34;_blank&#34;&gt;https://github.com/golang/build/commits/master/?author=qiulaidongfeng&lt;/a&gt;&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;&lt;a href=&#34;https://github.com/golang/sync/commits/master/?author=qiulaidongfeng&#34; target=&#34;_blank&#34;&gt;https://github.com/golang/sync/commits/master/?author=qiulaidongfeng&lt;/a&gt;&lt;/li&gt;&#xA;    &lt;li class=&#34;list-group-item&#34;&gt;&lt;a href=&#34;https://github.com/golang/website/commits/master/?author=qiulaidongfeng&#34; target=&#34;_blank&#34;&gt;https://github.com/golang/website/commits/master/?author=qiulaidongfeng&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div style=&#34;background-color: #f0f0f0;&#34;&gt;&#xA;    &lt;p&gt;如有商业开发需求，欢迎与我联系&lt;/p&gt;&#xA;    &lt;p&gt;联系方式：qiulaidongfeng@qq.com&lt;/p&gt;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>用redis构建聊天室</title>
      <link>https://qiulaidongfeng.github.io/zh-cn/%E7%94%A8redis%E6%9E%84%E5%BB%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</link>
      <pubDate>Mon, 21 Apr 2025 10:15:12 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/zh-cn/%E7%94%A8redis%E6%9E%84%E5%BB%BA%E8%81%8A%E5%A4%A9%E5%AE%A4/</guid>
      <description>&lt;p&gt;此博客记录我用redis构建聊天室的一个方案。&lt;/p&gt;&#xA;&lt;p&gt;首先，要实现的功能是聊天室可以被多个用户进入，在里面互相发消息聊天，能显示在线id数，聊天室会在一段时间没人发消息后自动删除。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;&#xA;&lt;p&gt;每个聊天室有一个名字，可以使用这个名字作为操作redis时的key。&lt;/p&gt;&#xA;&lt;h3 id=&#34;如何保存历史消息&#34;&gt;如何保存历史消息&lt;/h3&gt;&#xA;&lt;h4 id=&#34;性能太差不采用的&#34;&gt;性能太差不采用的&lt;/h4&gt;&#xA;&lt;p&gt;redis的string可以保存历史消息，通过将所有消息序列化为json之类保存，这样性能最差，因为消息要被重复的序列化和反序列化，所以不采用。&lt;/p&gt;&#xA;&lt;h4 id=&#34;不符合要求不采用的&#34;&gt;不符合要求不采用的&lt;/h4&gt;&#xA;&lt;p&gt;redis的发布订阅，可以构建非常简单的聊天室，但不能保存历史消息，且无法确保消息一定会被接收，所以不采用。&#xA;redis的位图，地理位置索引，HyperLogLog不能实现保存消息，所以不采用。&lt;/p&gt;&#xA;&lt;h4 id=&#34;实现更复杂不采用的&#34;&gt;实现更复杂不采用的&lt;/h4&gt;&#xA;&lt;p&gt;redis的哈希可以通过key是聊天室第n条发出消息的n,value是消息实现聊天室，意味着需要一个不断递增的n，增加了实现的复杂性，所以不采用。&#xA;redis的集合和有序集合，可以通过，聊天室第n条发出消息的n+消息的字符串插入到集合实现聊天室，同样因为需要不断递增的n，所以不采用。&#xA;redis的流相对其他数据类型更复杂，所以不采用。&lt;/p&gt;&#xA;&lt;h4 id=&#34;最终采用&#34;&gt;最终采用&lt;/h4&gt;&#xA;&lt;p&gt;redis的列表支持保存历史消息，可以被定时删除，而且通过lrange改参数start和end，很方便实现分页显示，不需要不断递增的n，所以采用。&lt;/p&gt;&#xA;&lt;h3 id=&#34;如何创建聊天室&#34;&gt;如何创建聊天室&lt;/h3&gt;&#xA;&lt;p&gt;通过在redis插入一个表示聊天室的key，值为列表。&lt;/p&gt;&#xA;&lt;p&gt;首先，要使用watch命令监视在redis表示聊天室的key，然后调用exists命令。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果key已经存在，说明聊天室已经创建，调用unwatch命令结束。&lt;/li&gt;&#xA;&lt;li&gt;如果key不存在，则开启事务进行插入。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;首先，调用multi命令开启事务，然后，调用rpush命令插入key，值是一个列表，第一个值为空字符串（rpush key &amp;ldquo;&amp;quot;），然后调用expire命令设置过期时间实现自动删除，例如要两小时自动删除，则实际调用（expire key 7200），接着调用exec执行事务，不考虑网络异常等，如果事务执行成功，聊天室创建成功，否则说明聊天室被其他用户创建。&lt;/p&gt;&#xA;&lt;h3 id=&#34;如何进入聊天室&#34;&gt;如何进入聊天室&lt;/h3&gt;&#xA;&lt;p&gt;利用redis在非集群模式可以有多数据库，实现可以是历史消息在db0，用户id在db1。&#xA;使用hash可以把一个聊天室的所有id放到一起，并对id分别设置不同的过期时间，所以采用这个数据结构。&lt;/p&gt;&#xA;&lt;p&gt;具体流程：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;随机生成一个id。&lt;/li&gt;&#xA;&lt;li&gt;使用hsetnx命令尝试插入用户id，命令的参数key是聊天室名，field是哈希的key是id，value是空字符串（hsetnx key id &amp;ldquo;&amp;quot;）。&lt;/li&gt;&#xA;&lt;li&gt;如失败，说明id已经被使用，回到1重来。&lt;/li&gt;&#xA;&lt;li&gt;如成功，使用hexpireat命令设置id的过期时间，注意该命令在redis7.4.0开始才有，例如假设现在Uinx时间戳是100，过期时间是20秒，则实际调用(hexpireat key 120 FIELDS id)。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;因为只有2成功才能执行4，且2同时多个用户执行只有一个成功，所以这里不需要使用事务。&lt;/p&gt;&#xA;&lt;p&gt;注意这里不需要更新聊天室的过期时间，因为有人但无人发消息的聊天室是不活跃的，和本来就没人的聊天室一样可以定时删除。&lt;/p&gt;&#xA;&lt;h3 id=&#34;如何发送文字消息到聊天室&#34;&gt;如何发送文字消息到聊天室&lt;/h3&gt;&#xA;&lt;p&gt;把文字消息发送到聊天室，只需要把文字消息插入到列表尾部，并且更新id的过期时间。&lt;/p&gt;&#xA;&lt;p&gt;rpush命令虽然可以做到这一点，但在聊天室不存在时也不会失败，而是产生第一个字符串非空的列表，破坏创建聊天室时产生的不变量，会造成后续获取历史消息时不显示第一条消息。&#xA;虽然通过事务和exists命令配合rpush命令可以解决上面的问题，但性能更差。&lt;/p&gt;&#xA;&lt;p&gt;rpushx命令在key不存在时不插入，解决了上面的问题，所以采用。&lt;/p&gt;&#xA;&lt;p&gt;具体流程：&#xA;在db0&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;调用rpushx key 文字消息。&lt;/li&gt;&#xA;&lt;li&gt;调用expire更新聊天室过期时间。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这里不需要事务，因为每条命令是原子操作就够了，即使前后调用多次expire，旧的调用后执行，最后结果也是，过期时间更新到当前时间+指定时长。&lt;/p&gt;&#xA;&lt;p&gt;在db1调用hexpireat更新id过期时间。&lt;/p&gt;&#xA;&lt;h3 id=&#34;如何获取历史消息等信息&#34;&gt;如何获取历史消息等信息&lt;/h3&gt;&#xA;&lt;p&gt;获取列表的所有元素即可获取历史消息，同时可以获取聊天室还有多久自动删除，以及在线id数。因为实践中，这样可以重复利用一个GET请求响应多个有关的数据，提升性能。&lt;/p&gt;&#xA;&lt;p&gt;具体流程：&#xA;在db0&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;调用lrange key 1 -1，获取列表存的所有历史文字消息。&lt;/li&gt;&#xA;&lt;li&gt;调用ttl key获取聊天室还有多久自动删除。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在db1&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;调用hexpireat更新id过期时间。&lt;/li&gt;&#xA;&lt;li&gt;调用hlen命令（hlen key）,获取在线id数。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;如何退出聊天室&#34;&gt;如何退出聊天室&lt;/h3&gt;&#xA;&lt;p&gt;在db1调用hdel key id即可。&#xA;可以客户端和服务端定时通信，客户端长时间无响应就自动退出聊天室。&lt;/p&gt;</description>
    </item>
    <item>
      <title>数据库配置tls的几个坑点</title>
      <link>https://qiulaidongfeng.github.io/zh-cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AEtls%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91%E7%82%B9/</link>
      <pubDate>Wed, 19 Mar 2025 19:22:51 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/zh-cn/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AEtls%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%91%E7%82%B9/</guid>
      <description>&lt;ol&gt;&#xA;&lt;li&gt;用docker安装的redis，配置tls时，许多网上相关的内容都是讲的生成证书和改redis配置文件的tls部分，但是没讲如果docker安装在wsl2，还要修改redis配置文件的bind为0.0.0.0。&lt;/li&gt;&#xA;&lt;li&gt;mongodb不支持tls1.3。&lt;/li&gt;&#xA;&lt;li&gt;mongodb和redis默认在启用tls时启用客户端证书验证，意味着默认只配置服务端证书验证还不能用tls连接mongodb和redis。&lt;/li&gt;&#xA;&lt;li&gt;一些网上讲用openssl自建ca签发tls证书的内容没有讲到证书SAN信息要包含服务端的域名或IP，不包含的话服务端使用这样的证书，客户端连接时会产生这样的错误Hostname/IP does not match certificate&amp;rsquo;s altnames: IP: 127.0.0.1 is not in the cert&amp;rsquo;s list:&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>在go标准库外实现比go标准库更好的arena</title>
      <link>https://qiulaidongfeng.github.io/zh-cn/%E5%9C%A8go%E6%A0%87%E5%87%86%E5%BA%93%E5%A4%96%E5%AE%9E%E7%8E%B0%E6%AF%94%E6%A0%87%E5%87%86%E5%BA%93%E6%9B%B4%E5%A5%BD%E7%9A%84arena/</link>
      <pubDate>Wed, 12 Feb 2025 03:36:31 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/zh-cn/%E5%9C%A8go%E6%A0%87%E5%87%86%E5%BA%93%E5%A4%96%E5%AE%9E%E7%8E%B0%E6%AF%94%E6%A0%87%E5%87%86%E5%BA%93%E6%9B%B4%E5%A5%BD%E7%9A%84arena/</guid>
      <description>&lt;p&gt;此博客介绍笔者是如何在go标准库外实现比go标准库更好的arena。&lt;/p&gt;&#xA;&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;&#xA;&lt;p&gt;arena是一种内存管理方法，从中分配的内存可以被同时释放，适合在一组object的生命周期相同或相近的场景使用，以减少垃圾收集开销。&lt;/p&gt;&#xA;&lt;p&gt;go1.22在标准库引入了一个实验性的arena，在这个的&lt;a href=&#34;https://github.com/golang/go/issues/51317&#34;&gt;issue&lt;/a&gt;，发出来没多久笔者就看到了，其中看到“为多个goroutine使用同一个arena是非常低效的。当然，这通常也没有什么意义，因为在不同的goroutine中分配的object的生命周期可能非常不同”，这里笔者印象很深，因为当时读到，笔者立刻就想到了一个多goroutine使用同一个arena的场景，是编译器解析多个源文件成抽象语法树，所有的节点生命周期都是相同的，而且支持goroutine使用到底有多低效呢？所以笔者在go标准库外试着实现了一个支持多goroutine使用的arena.&lt;/p&gt;&#xA;&lt;p&gt;当这里写在go标准库外实现比go标准库更好的arena，指的是&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单goroutine使用性能更好&lt;/li&gt;&#xA;&lt;li&gt;支持多goroutine使用&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基础实现&#34;&gt;基础实现&lt;/h3&gt;&#xA;&lt;p&gt;首先，准备一个持有一块内存的切片，和一个索引，称为buf，分配就是加索引，然后如果索引不大于长度，就获取这个切片这个索引的元素分配给调用者，不然就自动扩容，分配代码类似这样&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;realloc&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;slice&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;arena持有1个buf切片，最初里面有1个buf，它分配完就增加一个buf，以此类推，实现自动扩容。&#xA;一个简单的支持单goroutine的arena就是这么简单，后续就是在这基础上扩展。&lt;/p&gt;&#xA;&lt;h3 id=&#34;分配一组object&#34;&gt;分配一组object&lt;/h3&gt;&#xA;&lt;p&gt;go语言的切片类型可以表示一段内存，有n个T类型的object。&#xA;从arena分配一组object，利用这一点，可以比基础实现稍作修改，类似这样&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt; &amp;lt; &lt;span style=&#34;color:#a6e22e&#34;&gt;len&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;realloc&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;slice&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;num&lt;/span&gt;:&lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;真正支持分配任意类型&#34;&gt;真正支持分配任意类型&lt;/h3&gt;&#xA;&lt;p&gt;实现buf分配任意类型最简单的就是分配一个大的&lt;code&gt;[]uint8&lt;/code&gt;，要几个字节索引就加几，然后对切片返回slice[oldindex]的地址，通过unsafe.Pointer返回对应地址的指针，就可以将这块内存当做任意类型的值来使用。一些其他人实现的arena可以极高效率的在单goroutine场景分配任意类型的秘诀正在于此。&lt;/p&gt;&#xA;&lt;p&gt;这样做有一个问题，go语言的gc会把&lt;code&gt;[]uint8&lt;/code&gt;视作不含有指针的类型，所以，如果这里存有一个指针，它对gc隐藏起来了，在极端情况，可能一个object只有被隐藏的一个指针引用，这意味着gc可能将正在使用的内存回收，稍后发生use-after-free，程序可能因此崩溃。&lt;/p&gt;&#xA;&lt;p&gt;一种办法是分配&lt;code&gt;[]unsafe.pointer&lt;/code&gt;，但是这样的buf只能分配全是指针的类型，否则gc看到指针类型的内存存着不是有效的指针，会引发程序崩溃。&#xA;得益于go1.18添加的泛型，可以分配一个&lt;code&gt;[]T&lt;/code&gt;，T是任意类型，这样就可以像基础实现那样一个buf安全的分配一种类型的值。&lt;/p&gt;&#xA;&lt;p&gt;然后持有多个buf的变成一个类型的内存池，一个arena持有这些内存池，实现支持分配任意类型的支持单goroutine的arena。&lt;/p&gt;&#xA;&lt;h3 id=&#34;高性能的支持多goroutine&#34;&gt;高性能的支持多goroutine&lt;/h3&gt;&#xA;&lt;p&gt;支持多goroutine本身不难，任何只支持单goroutine的操作，加一个互斥锁就可以变成支持多gorutine的，但意味着只有CPU只有一个核被利用，很低效。&lt;/p&gt;&#xA;&lt;p&gt;简单的加一把读写锁也是不行的，从arena分配是写操作，读写锁适用于的是读多写少的场景。虽然arena获取特定类型的内存池，和从内存池获取多个buf的一个通常是最后一个正在使用的buf，在大多数时候是一个读操作，但注意，加读锁本身是通过原子加实现的，它是写操作，在多goroutine，随着竞争程度的增加，虽然因为使可以同时进行的读操作同时进行，性能比互斥锁更好，但还有提升的空间。&lt;/p&gt;&#xA;&lt;p&gt;原子写操作在多goroutine场景对性能的影响也是不可小觑的，一个例子就是arena获取特定类型的内存池时，比使用读写锁，采用笔者前段时间的博客 “用原子指针+互斥锁实现仅写时加锁” 里描述的方法，消除了热路径上的一个原子写操作，多goroutine性能提升了约30%。&lt;/p&gt;&#xA;&lt;p&gt;采用笔者前段时间的博客 “用原子指针+互斥锁实现仅写时加锁” 里描述的方法，程序根据是否大多数时候执行的代码路径，分为热路径和冷路径。&lt;/p&gt;&#xA;&lt;p&gt;热路径是不需要自动扩容时，顺利从内存池当前正在使用的buf分配的代码路径，热路径上只有一个原子写操作，是buf加索引时，目前没有办法消除这个原子写操作，热路径其他用到的同步就是原子读，所以确保了笔者实现的arena高性能的支持goroutine。&lt;/p&gt;&#xA;&lt;h3 id=&#34;支持重用内存&#34;&gt;支持重用内存&lt;/h3&gt;&#xA;&lt;p&gt;arena之所以能减少垃圾收集开销，在于它把一组生命周期相同或相似的object，一次全部释放，而这意味着有内存可以被立即重用，从而减少了gc运行的次数。顺带因此针对性实现，分配性能更好。如果只支持单gorutine，arena一次分配的性能开销可以压缩的一个加法，一个if判断，一个取地址，在大量分配小对象的场景，已经足以产生可观测的性能提升了。&lt;/p&gt;&#xA;&lt;p&gt;arena支持重用的内存，在于真正持有了一块连续内存的buf，go语言标准库提供的sync.Pool可以用来重用buf，可以把buf放进去，等需要时再取出实现重用内存。&lt;/p&gt;&#xA;&lt;p&gt;因为buf持有的内存大小不同，类型不同，所以将其放进sync.Pool，需要先找到同样类型的一些sync.Pool，在从中找到同样大小的sync.Pool，以确保安全的从同一个sync.Pool，得到的是同样类型持有同样大小内存的buf。&lt;/p&gt;&#xA;&lt;p&gt;依靠go语言标准库的sync.Map，可以高效的做到这一点&#xA;这是笔者写的做到上述做法的代码，其中的MemBlock和上文中的buf表示同样的含义。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;globarPool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Map&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getMemBlockPool&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;rtype&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;bufSize&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int64&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pool&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;have&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;globarPool&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Load&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;rtype&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;have&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt; = new(&lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Map&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;//无论是否成功，都说明同样类型的内存块的sync.Map有了&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;globarPool&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;LoadOrStore&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;rtype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;typmap&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Map&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;// 上面拿到了 每个类型不同的 sync.map , 里面有每个类型不同大小内存块的sync.Pool&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;typmap&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Load&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;bufSize&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;// 上面尝试拿 放着同样类型同样大小内存块的 sync.Pool&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;blockp&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;have&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pool&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;have&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;blockp&lt;/span&gt; = new(&lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pool&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;typmap&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;LoadOrStore&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;bufSize&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;blockp&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;// Note 这里的类型断言肯定成功,因为如果是写操作，得到的是刚刚的new(sync.Pool),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;// 如果是读操作，读到的是其他goroutine写的new(sync.Pool)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;blockp&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;.(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pool&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#75715e&#34;&gt;// 上面拿到了 放着同样类型相同大小内存块的 sync.Pool&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;blockp&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;给arena一个Free方法，当这个方法被调用时，将内存池的buf放入sync.Pool。&#xA;然后只需要再从arena分配时，要分配的类型的内存池首先尝试从sync.Pool获取buf，就实现了重用内存。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go语言tls1.3密码套件修改研究</title>
      <link>https://qiulaidongfeng.github.io/zh-cn/go%E8%AF%AD%E8%A8%80tls1.3%E5%AF%86%E7%A0%81%E5%A5%97%E4%BB%B6%E4%BF%AE%E6%94%B9%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Tue, 11 Feb 2025 20:00:46 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/zh-cn/go%E8%AF%AD%E8%A8%80tls1.3%E5%AF%86%E7%A0%81%E5%A5%97%E4%BB%B6%E4%BF%AE%E6%94%B9%E7%A0%94%E7%A9%B6/</guid>
      <description>&lt;p&gt;有些浏览器可以看到tls的一些信息，例如&#xA;&lt;img src=&#34;https://qiulaidongfeng.github.io/images/s.jpg&#34; alt=&#34;&#34;&gt;&#xA;笔者看到go语言默认用的aes128,其他tls1.3实现有默认用aes256的。&lt;/p&gt;&#xA;&lt;p&gt;go语言的tls默认tls1.3使用下列密码套件按下列顺序&#xA;TLS_AES_128_GCM_SHA256,&#xA;TLS_AES_256_GCM_SHA384,&#xA;TLS_CHACHA20_POLY1305_SHA256&#xA;并且文档中明确列出TLS 1.3 ciphersuites are not configurable(TLS 1.3密码套件是不可配置的)&lt;/p&gt;&#xA;&lt;p&gt;笔者试了类似这个程序&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;crypto/tls&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;net/http&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;unsafe&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//go:linkname defaultCipherSuitesTLS13 tls.defaultCipherSuitesTLS13&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;defaultCipherSuitesTLS13&lt;/span&gt; = []&lt;span style=&#34;color:#66d9ef&#34;&gt;uint16&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;tls&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;TLS_AES_256_GCM_SHA384&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;tls&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;TLS_CHACHA20_POLY1305_SHA256&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;tls&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Config&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;MinVersion&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;tls&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;VersionTLS13&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Server&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;Addr&lt;/span&gt;:      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:443&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;TLSConfig&lt;/span&gt;: &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;c&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;mux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;NewServeMux&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Handler&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;mux&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;mux&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;HandleFunc&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ResponseWriter&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;req&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;http&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Request&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Fprintln&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;w&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;})&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ListenAndServeTLS&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;`cert_path`&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;`key_path`&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;确实一般情况下无法配置。&#xA;研究确认，修改go语言tls包的defaults.go源文件中defaultCipherSuitesTLS13可以做到其他tls1.3实现的效果&#xA;只需将原本的&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;defaultCipherSuitesTLS13&lt;/span&gt; = []&lt;span style=&#34;color:#66d9ef&#34;&gt;uint16&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;TLS_AES_128_GCM_SHA256&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;TLS_AES_256_GCM_SHA384&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;TLS_CHACHA20_POLY1305_SHA256&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;改为&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;defaultCipherSuitesTLS13&lt;/span&gt; = []&lt;span style=&#34;color:#66d9ef&#34;&gt;uint16&lt;/span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;TLS_AES_256_GCM_SHA384&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#a6e22e&#34;&gt;TLS_CHACHA20_POLY1305_SHA256&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>用原子指针&#43;互斥锁实现仅写时加锁</title>
      <link>https://qiulaidongfeng.github.io/zh-cn/%E7%94%A8%E5%8E%9F%E5%AD%90%E6%8C%87%E9%92%88&#43;%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E4%BB%85%E5%86%99%E6%97%B6%E5%8A%A0%E9%94%81/</link>
      <pubDate>Tue, 17 Dec 2024 20:00:37 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/zh-cn/%E7%94%A8%E5%8E%9F%E5%AD%90%E6%8C%87%E9%92%88&#43;%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E4%BB%85%E5%86%99%E6%97%B6%E5%8A%A0%E9%94%81/</guid>
      <description>&lt;p&gt;此博客介绍我写&lt;a href=&#34;https://github.com/qiulaidongfeng/arena&#34;&gt;arena&lt;/a&gt;的一个经验。&lt;/p&gt;&#xA;&lt;p&gt;通常在访问共享资源时，简单的加互斥锁就够用，在读多写少时使用读写锁优化性能，在写&lt;a href=&#34;https://github.com/qiulaidongfeng/arena&#34;&gt;arena&lt;/a&gt;等场景，为了极致的性能，需要别的方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;回顾一些知识说明为什么互斥锁和读写锁不适合用在需要极致性能时&#34;&gt;回顾一些知识，说明为什么互斥锁和读写锁不适合用在需要极致性能时。&lt;/h2&gt;&#xA;&lt;p&gt;为什么访问共享资源时需要加锁，因为如果不加锁，多个线程可能看到正在进行操作的中间状态，并基于此中间状态执行它自己的一些操作，导致错误结果。&lt;/p&gt;&#xA;&lt;p&gt;一个简单的例子说明这一点：&lt;/p&gt;&#xA;&lt;p&gt;如果对变量i进行加1，CPU的执行步骤是&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;读取i的值到寄存器&lt;/li&gt;&#xA;&lt;li&gt;执行加1&lt;/li&gt;&#xA;&lt;li&gt;结果写回i&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;如果两个线程直接对变量i加1，可能的执行步骤是&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;两个线程读取i的值（i=1）到寄存器&lt;/li&gt;&#xA;&lt;li&gt;执行加1,得到2&lt;/li&gt;&#xA;&lt;li&gt;结果写回i,结果i=2&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这样导致i被加了两次1但是结果却不是正确的3。&lt;/p&gt;&#xA;&lt;p&gt;对于这种情况，CPU提供了原子操作，避免了这样因为看到其他线程操作的中间状态，导致错误结果。&lt;/p&gt;&#xA;&lt;p&gt;CPU提供的原子操作包括原子加，原子读，原子写，原子交换等，适用于很小的数据。在一些简单的场景，如记录网站访问量，这样简单的对一个整数作加法这种场景是足够的，但在更复杂的场景不够。&lt;/p&gt;&#xA;&lt;p&gt;对于更复杂的场景，基于原子操作产生了互斥锁。互斥锁有加锁和解锁两个操作，一把锁加锁了必须解锁才能再加锁，这样避免在更复杂的场景看到其他线程操作的中间状态。&lt;/p&gt;&#xA;&lt;p&gt;用伪代码表示，互斥锁通常这样使用&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Mutex&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Lock&lt;/span&gt;()&lt;span style=&#34;color:#75715e&#34;&gt;//加锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//复杂的操作&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unlock&lt;/span&gt;()&lt;span style=&#34;color:#75715e&#34;&gt;//解锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为互斥锁的特性（一把锁加锁了必须解锁才能再加锁），所以可以确保复杂的操作在锁的保护中，不会被看到它操作时的中间状态，从而避免了错误结果。&lt;/p&gt;&#xA;&lt;p&gt;简单的互斥锁用go语言写扣除空行，完整实现只需要5行代码&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;package&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mutex&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sync/atomic&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Mutex&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int32&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Mutex&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Lock&lt;/span&gt;() {&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;atomic&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CompareAndSwapInt32&lt;/span&gt;((&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int32&lt;/span&gt;)(&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {}}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Mutex&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Unlock&lt;/span&gt;() {&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; !&lt;span style=&#34;color:#a6e22e&#34;&gt;atomic&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;CompareAndSwapInt32&lt;/span&gt;((&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int32&lt;/span&gt;)(&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;), &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {}}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;很简单，就是一个整数，用原子操作，加锁就为0时改成1，解锁就为1时改成0。这样就可以实现了一个能用的互斥锁。&lt;/p&gt;&#xA;&lt;p&gt;因为读操作与写操作不同，读操作不会改变什么，它没有中间状态，它只需要不会写操作同时进行，就可以多个线程同时进行读操作。在读多写少的场景，使用互斥锁让可以同时进行的读操作分开进行，会降低性能，所以产生了读写锁。&lt;/p&gt;&#xA;&lt;p&gt;读写锁是这样的锁：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;有读锁和写锁。&lt;/li&gt;&#xA;&lt;li&gt;不能同时加读锁没解锁和加写锁没解锁，其中一种加锁要等待另一种加锁后解锁才能。&lt;/li&gt;&#xA;&lt;li&gt;写锁就像互斥锁。&lt;/li&gt;&#xA;&lt;li&gt;读锁可以加锁n次，但解锁也要n次，否则加写锁永远不会成功。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;用伪代码表示，读写锁通常这样使用&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RWMutex&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//写操作&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Lock&lt;/span&gt;()&lt;span style=&#34;color:#75715e&#34;&gt;//加写锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//执行写操作&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unlock&lt;/span&gt;()&lt;span style=&#34;color:#75715e&#34;&gt;//解写锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//读操作&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;RLock&lt;/span&gt;()&lt;span style=&#34;color:#75715e&#34;&gt;//加读锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//执行读操作&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;RUnlock&lt;/span&gt;()&lt;span style=&#34;color:#75715e&#34;&gt;//解读锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样因为读写锁的特性，所以写操作不会和读操作同时进行，多个读操作可以同时进行，比互斥锁提高了读多写少时的性能。&lt;/p&gt;&#xA;&lt;p&gt;互斥锁和读写锁都基于原子操作实现，并且是使用原子加等相对性能更差的原子操作实现，性能随着CPU核数增加反而可能更差，所以在需要极致性能时，不适合。&lt;/p&gt;&#xA;&lt;h2 id=&#34;仅写时加锁&#34;&gt;仅写时加锁&lt;/h2&gt;&#xA;&lt;p&gt;在写&lt;a href=&#34;https://github.com/qiulaidongfeng/arena&#34;&gt;arena&lt;/a&gt;时，存在读多写少的场景，并且读操作特别多。每次都加读锁不能达到极致的性能。&lt;/p&gt;&#xA;&lt;p&gt;在原子操作中，原子读相对性能更好。并且数据在内存中有内存地址，它可以进行原子读。&lt;/p&gt;&#xA;&lt;p&gt;所以可以将使用读写锁的代码，用原子指针+互斥锁（对内存地址进行原子操作的指针）改写成这样代码：&lt;/p&gt;&#xA;&lt;p&gt;一个伪代码展示通用的模版：&lt;/p&gt;&#xA;&lt;p&gt;使用读写时的代码&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RWMutex&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; []&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;//共享数据&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//写操作&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Lock&lt;/span&gt;()&lt;span style=&#34;color:#75715e&#34;&gt;//加写锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//执行写操作，例如&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;=make([]&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unlock&lt;/span&gt;()&lt;span style=&#34;color:#75715e&#34;&gt;//解写锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//读操作&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;RLock&lt;/span&gt;()&lt;span style=&#34;color:#75715e&#34;&gt;//加读锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//执行读操作，例如&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lock&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;RUnlock&lt;/span&gt;()&lt;span style=&#34;color:#75715e&#34;&gt;//解读锁&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;改写为用原子指针的代码：&lt;/p&gt;</description>
    </item>
    <item>
      <title>go1.24rc1发布</title>
      <link>https://qiulaidongfeng.github.io/zh-cn/go1-24rc1%E5%8F%91%E5%B8%83/</link>
      <pubDate>Mon, 16 Dec 2024 22:46:29 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/zh-cn/go1-24rc1%E5%8F%91%E5%B8%83/</guid>
      <description>&lt;p&gt;go1.24rc1已经发布，值得注意的是&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;抗量子密钥交换（crypto/mlkem）&lt;/li&gt;&#xA;&lt;li&gt;弱指针&lt;/li&gt;&#xA;&lt;li&gt;通用哈希函数（我写的实现）&lt;/li&gt;&#xA;&lt;li&gt;泛型类型别名&lt;/li&gt;&#xA;&lt;li&gt;更快的终结器&lt;/li&gt;&#xA;&lt;li&gt;CPU开销平均降低2-3%，改进包括新的map内置实现，更高效的小object内存分配，新的运行时内部互斥实现&lt;/li&gt;&#xA;&lt;li&gt;实验性包testing/synctest用来测试并发代码&lt;/li&gt;&#xA;&lt;li&gt;sync.Map的新实现，提高了性能&lt;/li&gt;&#xA;&lt;li&gt;os.Root用来在特定目录执行文件系统操作&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>How does the metrics package record the number of non default behavior occurrences</title>
      <link>https://qiulaidongfeng.github.io/en/howdoesthemetricspackagerecordthenumberofnondefaultbehavioroccurrences-md/</link>
      <pubDate>Thu, 06 Apr 2023 14:19:16 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/en/howdoesthemetricspackagerecordthenumberofnondefaultbehavioroccurrences-md/</guid>
      <description>&lt;h1 id=&#34;go121-forward-looking&#34;&gt;Go1.21 Forward Looking&lt;/h1&gt;&#xA;&lt;p&gt;Software translation&lt;/p&gt;&#xA;&lt;h2 id=&#34;how-does-the-metrics-package-record-the-number-of-non-default-behavior-occurrences&#34;&gt;How does the metrics package record the number of non default behavior occurrences&lt;/h2&gt;&#xA;&lt;p&gt;Go1.21 is currently under development, &lt;a href=&#34;https://tip.golang.org/doc/go1.21&#34;&gt;draft release note&lt;/a&gt;It is mentioned that it is expected to be released in August 2023.&lt;/p&gt;&#xA;&lt;p&gt;In the development branch of &lt;a href=&#34;https://github.com/golang/go&#34;&gt;go1.21&lt;/a&gt; In, &lt;a href=&#34;https://pkg.go.dev/runtime/metrics@master&#34;&gt;metrics&lt;/a&gt;  package, a series of indicators in the format /godebug/non-default-behavior/(godebug-name):events ,(godebug name) is a series of key value pairs for GODEBUG environment variables, and the names of certain keys, such as the execerrdot introduced in go1.19 (hereinafter referred to as &lt;strong&gt;godebug indicator&lt;/strong&gt;). &lt;strong&gt;Through these newly added indicators, the number of non default behavior occurrences caused by setting these environmental variables can be obtained.&lt;/strong&gt; This article analyzes how this is achieved by studying the source code.&lt;/p&gt;</description>
    </item>
    <item>
      <title>metrics包如何记录非默认行为发生次数</title>
      <link>https://qiulaidongfeng.github.io/zh-cn/metrics%E5%8C%85%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95%E9%9D%9E%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%E5%8F%91%E7%94%9F%E6%AC%A1%E6%95%B0-md/</link>
      <pubDate>Thu, 06 Apr 2023 00:00:00 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/zh-cn/metrics%E5%8C%85%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95%E9%9D%9E%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%E5%8F%91%E7%94%9F%E6%AC%A1%E6%95%B0-md/</guid>
      <description>&lt;h1 id=&#34;go121前瞻&#34;&gt;go1.21前瞻&lt;/h1&gt;&#xA;&lt;h2 id=&#34;metrics包如何记录非默认行为发生次数&#34;&gt;metrics包如何记录非默认行为发生次数&lt;/h2&gt;&#xA;&lt;p&gt;go1.21正在开发中，&lt;a href=&#34;https://tip.golang.org/doc/go1.21&#34;&gt;发行说明草案&lt;/a&gt; 提到预计2023年8月发布。&lt;/p&gt;&#xA;&lt;p&gt;在go1.21的&lt;a href=&#34;https://github.com/golang/go&#34;&gt;开发分支&lt;/a&gt;中，&lt;a href=&#34;https://pkg.go.dev/runtime/metrics@master&#34;&gt;metrics&lt;/a&gt; 包中，新增了一系列格式如同 /godebug/non-default-behavior/(godebug-name):events的指标，(godebug-name)是GODEBUG环境变量的一系列键值对，某些键的名称，比如go1.19引入的execerrdot（以下简称&lt;strong&gt;godebug指标&lt;/strong&gt;）。通过这些新增的指标，可以获取&lt;strong&gt;因为设置了这些环境变量导致非默认行为发生次数的数量&lt;/strong&gt;，本文通过研究源代码来分析这是如何实现的。&lt;/p&gt;&#xA;&lt;p&gt;首先，本文使用的是go标准库源代码(通过gotip安装)，具体版本号（go version devel go1.21-8d68b388d4 Wed Apr 5 21:45:24 2023 +0000 windows/amd64）。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;在go标准库的internal/godebug包有如下API:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Setting&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;New&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Setting&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Setting&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;IncNonDefault&lt;/span&gt;()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Setting&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Setting&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Setting&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Value&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在Setting结构体中，有一个非默认行为计数器，类型是atomic.Uint64，这是一个在go1.19引入的原子类型，API如下&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Uint64&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Uint64&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Add&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;delta&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt;) (&lt;span style=&#34;color:#a6e22e&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Uint64&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;CompareAndSwap&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;old&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt;) (&lt;span style=&#34;color:#a6e22e&#34;&gt;swapped&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Uint64&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Load&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Uint64&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Store&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;val&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Uint64&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;Swap&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt;) (&lt;span style=&#34;color:#a6e22e&#34;&gt;old&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个结构体的IncNonDefault方法每次调用时非默认行为计数器都会原子加1，在第一次调用时还会将非默认行为计数器的Load方法通过runtime包的godebug_registerMetric函数设置为获取godebug指标对应的值的函数。&lt;/p&gt;&#xA;&lt;p&gt;这样通过每次非默认行为发生时都调用IncNonDefault方法，就可以在Setting结构体中记录非默认行为发生次数。&lt;/p&gt;&#xA;&lt;p&gt;godebug_registerMetric函数签名如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;godebug_registerMetric&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;uint64&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个函数将name参数的值表示的指标，获取指标对应的值的函数设置为read参数传递的参数。&lt;/p&gt;&#xA;&lt;p&gt;metrics包获取godebug指标对应的值的能力来源于runtime包。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;这样，非默认行为发生次数被记录和获取的顺序是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;go标准库的每个godebug选项都通过internal/godebug包的New()函数创建，返回值包含非默认行为计数器。&lt;/li&gt;&#xA;&lt;li&gt;每次非默认行为发生时都会调用Setting结构体的IncNonDefault方法。&lt;/li&gt;&#xA;&lt;li&gt;IncNonDefault方法将获取godebug指标对应的值的函数设置为非默认行为计数器的Load方法。&lt;/li&gt;&#xA;&lt;li&gt;IncNonDefault方法将非默认行为计数器原子加1。&lt;/li&gt;&#xA;&lt;li&gt;每次godebug指标对应的值被获取，都会调用非默认行为计数器的Load方法，这样就实现了metrics包有记录非默认行为发生次数的现象（实际记录在Setting结构体，只是metrics包通过runtime包，runtime包通过调用Setting结构体的非默认行为计数器的Load方法展现出了这种现象）。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Multiplication_or_dereference</title>
      <link>https://qiulaidongfeng.github.io/en/multiplication-or-dereference-md/</link>
      <pubDate>Sun, 19 Mar 2023 00:00:00 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/en/multiplication-or-dereference-md/</guid>
      <description>&lt;h1 id=&#34;multiplication-or-dereference&#34;&gt;Multiplication or dereference&lt;/h1&gt;&#xA;&lt;p&gt;Software translation&lt;/p&gt;&#xA;&lt;p&gt;In the &lt;a href=&#34;https://gitee.com/u-language/u-language&#34;&gt;U Language Project&lt;/a&gt; A separator based lexical analyzer is implemented in the &lt;a href=&#34;https://gitee.com/u-language/u-language/blob/master/pkg/lex/README.md&#34;&gt;Lexical Analyzer Design Document&lt;/a&gt; &amp;ldquo;The current * will be parsed as a multiplication sign, and when there is no pointer, there is no problem.&amp;rdquo;. Now we are ready to add pointers to this project. If you use * to dereference as in other languages, there are two options&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;When constructing an abstract syntax tree, handle ambiguity where * can be both a multiplication sign and a dereference&lt;/p&gt;</description>
    </item>
    <item>
      <title>乘法还是解引用</title>
      <link>https://qiulaidongfeng.github.io/zh-cn/%E4%B9%98%E6%B3%95%E8%BF%98%E6%98%AF%E8%A7%A3%E5%BC%95%E7%94%A8-md/</link>
      <pubDate>Sun, 19 Mar 2023 00:00:00 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/zh-cn/%E4%B9%98%E6%B3%95%E8%BF%98%E6%98%AF%E8%A7%A3%E5%BC%95%E7%94%A8-md/</guid>
      <description>&lt;h1 id=&#34;乘法还是解引用&#34;&gt;乘法还是解引用&lt;/h1&gt;&#xA;&lt;p&gt;在 &lt;a href=&#34;https://gitee.com/u-language/u-language&#34;&gt;U语言项目&lt;/a&gt; 中 ，实现了一个基于分隔符的词法分析器，文档在 &lt;a href=&#34;https://gitee.com/u-language/u-language/blob/master/pkg/lex/README.md&#34;&gt;词法分析器设计文档&lt;/a&gt; ，当前 * 将被分析为乘号，在没有指针时，这样没有问题。现在准备给这个项目增加指针，如果按其他语言一样使用 * 解引用，有两种方案&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在构建抽象语法树时处理 * 既可以是乘号又可以解引用的二义性&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在词法分析节点处理 *  既可以是乘号又可以解引用的二义性&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;如何解决--二义性&#34;&gt;如何解决 * 二义性&lt;/h2&gt;&#xA;&lt;p&gt;当编译器看到 一个 * 处理既可以是乘号又可以解引用的二义性，首先没有直接解释为乘号或解引用一种语义的方法，枚举证明&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果直接解释为 乘号 ，对于 *ptr=1 的 *ptr是解引用ptr指针，现在被错误的解释成乘ptr&lt;/li&gt;&#xA;&lt;li&gt;如果直接解释为 解引用 ， 对于 c =a*b 的 *b是乘b，现在被错误的解释成解引用b&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;所以需要根据不同情况解释 * ，对于 *&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果在开头，因为乘法需要两个操作数，在开头表示左边没有操作数，所以可以解释为解引用&lt;/li&gt;&#xA;&lt;li&gt;如果不在开头，如果 * 前面不是符号，比如 a+*ptr，因为左边不是操作数，所以可以解释为解引用&lt;/li&gt;&#xA;&lt;li&gt;如果不在开头，如果 * 是符号，比如 a*b，因为左边是操作数，所以可以解释为乘号&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;上述处理方法在词法分析或构建抽象语法树，都可以，但是在词法分析的时候通过一个布尔变量，在发现乘号时设置为true,在末尾判断如果布尔变量为true则按上述方法处理乘号，对于没有乘号的部分只增加一次判断的开销。&lt;/p&gt;&#xA;&lt;h2 id=&#34;更简单的办法&#34;&gt;更简单的办法&lt;/h2&gt;&#xA;&lt;p&gt;如果* 有二义性，除了处理二义性还可以找一个没有二义性的符号，比如@，然后编译器看到@就可以直接的识别为解引用，只不过这样和主流做法有区别，可能增加学习成本&lt;/p&gt;</description>
    </item>
    <item>
      <title>mmap_error</title>
      <link>https://qiulaidongfeng.github.io/en/mmap-error/</link>
      <pubDate>Thu, 02 Mar 2023 21:00:49 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/en/mmap-error/</guid>
      <description>&lt;h1 id=&#34;go121-forward-looking&#34;&gt;Go1.21 forward-looking&lt;/h1&gt;&#xA;&lt;p&gt;Software translation&lt;/p&gt;&#xA;&lt;h2 id=&#34;windows-allows-handling-exception-page-errors&#34;&gt;Windows allows handling exception page errors&lt;/h2&gt;&#xA;&lt;p&gt;Go1.21 is under development, &lt;a href=&#34;https://tip.golang.org/doc/go1.21&#34;&gt;draft release note&lt;/a&gt; Mention that it is expected to be released in August 2023&lt;/p&gt;&#xA;&lt;p&gt;According to the submitted information &lt;a href=&#34;https://github.com/golang/go/commit/e03ee85ef434f307500a71927dfb3e876161847a&#34;&gt;runtime: Allow handling of EXCEPTION_IN_PAGE_ERROR&lt;/a&gt; Go1.21 allows you to handle the access failure of the memory-mapped file through debug.SetPanicOnFault in Windows (for example, the drive where the memory-mapped file is located is ejected)&lt;/p&gt;&#xA;&lt;p&gt;For example, it comes from &lt;a href=&#34;https://github.com/golang/go/issues/58457&#34;&gt;golang/go#58457&lt;/a&gt; Example of&lt;/p&gt;</description>
    </item>
    <item>
      <title>mmap错误</title>
      <link>https://qiulaidongfeng.github.io/zh-cn/mmap%E9%94%99%E8%AF%AF/</link>
      <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/zh-cn/mmap%E9%94%99%E8%AF%AF/</guid>
      <description>&lt;h1 id=&#34;go121前瞻&#34;&gt;go1.21前瞻&lt;/h1&gt;&#xA;&lt;h2 id=&#34;windows允许处理异常页面错误&#34;&gt;windows允许处理异常页面错误&lt;/h2&gt;&#xA;&lt;p&gt;go1.21正在开发中，&lt;a href=&#34;https://tip.golang.org/doc/go1.21&#34;&gt;发行说明草案&lt;/a&gt; 提到预计2023年8月发布&lt;/p&gt;&#xA;&lt;p&gt;根据提交信息 &lt;a href=&#34;https://github.com/golang/go/commit/e03ee85ef434f307500a71927dfb3e876161847a&#34;&gt;runtime: Allow handling of EXCEPTION_IN_PAGE_ERROR&lt;/a&gt; go1.21允许在windows通过debug.SetPanicOnFault 处理内存映射文件的访问故障（例如，内存映射文件所在的驱动器被弹出）&lt;/p&gt;&#xA;&lt;p&gt;例如来源于 &lt;a href=&#34;https://github.com/golang/go/issues/58457&#34;&gt;golang/go#58457&lt;/a&gt;的例子&#xA;内存映射外部磁盘上的文件(使用CreateFileMapping / MapViewOfFile)&#xA;调用debug.SetPanicOnFault(true)&#xA;弹出外部磁盘&#xA;尝试从内存映射中读取&lt;/p&gt;&#xA;&lt;p&gt;看到的是？&#xA;The runtime faults (Exception 0xc0000006 0x0 &amp;hellip;)&#xA;这不是panic,不能通过recover恢复&lt;/p&gt;&#xA;&lt;p&gt;go1.21应该是看到的 panic &amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;根据 &lt;a href=&#34;https://pkg.go.dev/runtime/debug#SetPanicOnFault&#34;&gt;SetPanicOnFault文档&lt;/a&gt;这种情况当 调用debug.SetPanicOnFault(true) 后使用内存映射文件的程序或不安全的内存操作可能会导致非零地址出错；SetPanicOnFault允许这样的程序请求运行时只触发一次panic，根据&lt;a href=&#34;https://github.com/golang/go/issues/58457&#34;&gt;golang/go#58457&lt;/a&gt; 至少在go1.19不是这样，截至发布前，没看到go官方打算将修复的提交反向移植到go1.20和go1.19的下一个次要版本&lt;/p&gt;</description>
    </item>
    <item>
      <title>First blog</title>
      <link>https://qiulaidongfeng.github.io/en/one/</link>
      <pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/en/one/</guid>
      <description>&lt;p&gt;Software translation&#xA;On March 1, 2023, I published this blog&lt;/p&gt;</description>
    </item>
    <item>
      <title>第一个博客</title>
      <link>https://qiulaidongfeng.github.io/zh-cn/one/</link>
      <pubDate>Wed, 01 Mar 2023 00:00:00 +0000</pubDate>
      <author>秋来冬风</author>
      <guid>https://qiulaidongfeng.github.io/zh-cn/one/</guid>
      <description>&lt;p&gt;2023年3月1日，我公开了这个博客&lt;/p&gt;</description>
    </item>
  </channel>
</rss>