<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋来冬风的博客</title>
  
  
  <link href="https://qiulaidongfeng.github.io/atom.xml" rel="self"/>
  
  <link href="https://qiulaidongfeng.github.io/"/>
  <updated>2025-02-13T12:18:35.882Z</updated>
  <id>https://qiulaidongfeng.github.io/</id>
  
  <author>
    <name>秋来冬风</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在go标准库外实现比go标准库更好的arena</title>
    <link href="https://qiulaidongfeng.github.io/zh-cn/%E5%9C%A8go%E6%A0%87%E5%87%86%E5%BA%93%E5%A4%96%E5%AE%9E%E7%8E%B0%E6%AF%94%E6%A0%87%E5%87%86%E5%BA%93%E6%9B%B4%E5%A5%BD%E7%9A%84arena/"/>
    <id>https://qiulaidongfeng.github.io/zh-cn/%E5%9C%A8go%E6%A0%87%E5%87%86%E5%BA%93%E5%A4%96%E5%AE%9E%E7%8E%B0%E6%AF%94%E6%A0%87%E5%87%86%E5%BA%93%E6%9B%B4%E5%A5%BD%E7%9A%84arena/</id>
    <published>2025-02-11T19:36:31.000Z</published>
    <updated>2025-02-13T12:18:35.882Z</updated>
    
    <content type="html"><![CDATA[<p>此博客介绍笔者是如何在go标准库外实现比go标准库更好的arena。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>arena是一种内存管理方法，从中分配的内存可以被同时释放，适合在一组object的生命周期相同或相近的场景使用，以减少垃圾收集开销。</p><p>go1.22在标准库引入了一个实验性的arena，在这个的<a href="https://github.com/golang/go/issues/51317">issue</a>，发出来没多久笔者就看到了，其中看到“为多个goroutine使用同一个arena是非常低效的。当然，这通常也没有什么意义，因为在不同的goroutine中分配的object的生命周期可能非常不同”，这里笔者印象很深，因为当时读到，笔者立刻就想到了一个多goroutine使用同一个arena的场景，是编译器解析多个源文件成抽象语法树，所有的节点生命周期都是相同的，而且支持goroutine使用到底有多低效呢？所以笔者在go标准库外试着实现了一个支持多goroutine使用的arena.</p><p>当这里写在go标准库外实现比go标准库更好的arena，指的是</p><ul><li>单goroutine使用性能更好</li><li>支持多goroutine使用</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><p>首先，准备一个持有一块内存的切片，和一个索引，称为buf，分配就是加索引，然后如果索引不大于长度，就获取这个切片这个索引的元素分配给调用者，不然就自动扩容，分配代码类似这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index = index + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span> &#123;</span><br><span class="line">    realloc()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slice[index]</span><br></pre></td></tr></table></figure><p>arena持有1个buf切片，最初里面有1个buf，它分配完就增加一个buf，以此类推，实现自动扩容。<br>一个简单的支持单goroutine的arena就是这么简单，后续就是在这基础上扩展。</p><h3 id="分配一组object"><a href="#分配一组object" class="headerlink" title="分配一组object"></a>分配一组object</h3><p>go语言的切片类型可以表示一段内存，有n个T类型的object。<br>从arena分配一组object，利用这一点，可以比基础实现稍作修改，类似这样</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">index = index + num</span><br><span class="line"><span class="keyword">if</span> index &lt; <span class="built_in">len</span> &#123;</span><br><span class="line">    realloc()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slice[index-num:index]</span><br></pre></td></tr></table></figure><h3 id="真正支持分配任意类型"><a href="#真正支持分配任意类型" class="headerlink" title="真正支持分配任意类型"></a>真正支持分配任意类型</h3><p>实现buf分配任意类型最简单的就是分配一个大的<code>[]uint8</code>，要几个字节索引就加几，然后对切片返回slice[oldindex]的地址，通过unsafe.Pointer返回对应地址的指针，就可以将这块内存当做任意类型的值来使用。一些其他人实现的arena可以极高效率的在单goroutine场景分配任意类型的秘诀正在于此。</p><p>这样做有一个问题，go语言的gc会把<code>[]uint8</code>视作不含有指针的类型，所以，如果这里存有一个指针，它对gc隐藏起来了，在极端情况，可能一个object只有被隐藏的一个指针引用，这意味着gc可能将正在使用的内存回收，稍后发生use-after-free，程序可能因此崩溃。</p><p>一种办法是分配<code>[]unsafe.pointer</code>，但是这样的buf只能分配全是指针的类型，否则gc看到指针类型的内存存着不是有效的指针，会引发程序崩溃。<br>得益于go1.18添加的泛型，可以分配一个<code>[]T</code>，T是任意类型，这样就可以像基础实现那样一个buf安全的分配一种类型的值。</p><p>然后持有多个buf的变成一个类型的内存池，一个arena持有这些内存池，实现支持分配任意类型的支持单goroutine的arena。</p><h3 id="高性能的支持多goroutine"><a href="#高性能的支持多goroutine" class="headerlink" title="高性能的支持多goroutine"></a>高性能的支持多goroutine</h3><p>支持多goroutine本身不难，任何只支持单goroutine的操作，加一个互斥锁就可以变成支持多gorutine的，但意味着只有CPU只有一个核被利用，很低效。</p><p>简单的加一把读写锁也是不行的，从arena分配是写操作，读写锁适用于的是读多写少的场景。虽然arena获取特定类型的内存池，和从内存池获取多个buf的一个通常是最后一个正在使用的buf，在大多数时候是一个读操作，但注意，加读锁本身是通过原子加实现的，它是写操作，在多goroutine，随着竞争程度的增加，虽然因为使可以同时进行的读操作同时进行，性能比互斥锁更好，但还有提升的空间。</p><p>原子写操作在多goroutine场景对性能的影响也是不可小觑的，一个例子就是arena获取特定类型的内存池时，比使用读写锁，采用笔者前段时间的博客 “用原子指针+互斥锁实现仅写时加锁” 里描述的方法，消除了热路径上的一个原子写操作，多goroutine性能提升了约30%。</p><p>采用笔者前段时间的博客 “用原子指针+互斥锁实现仅写时加锁” 里描述的方法，程序根据是否大多数时候执行的代码路径，分为热路径和冷路径。</p><p>热路径是不需要自动扩容时，顺利从内存池当前正在使用的buf分配的代码路径，热路径上只有一个原子写操作，是buf加索引时，目前没有办法消除这个原子写操作，热路径其他用到的同步就是原子读，所以确保了笔者实现的arena高性能的支持goroutine。</p><h3 id="支持重用内存"><a href="#支持重用内存" class="headerlink" title="支持重用内存"></a>支持重用内存</h3><p>arena之所以能减少垃圾收集开销，在于它把一组生命周期相同或相似的object，一次全部释放，而这意味着有内存可以被立即重用，从而减少了gc运行的次数。顺带因此针对性实现，分配性能更好。如果只支持单gorutine，arena一次分配的性能开销可以压缩的一个加法，一个if判断，一个取地址，在大量分配小对象的场景，已经足以产生可观测的性能提升了。</p><p>arena支持重用的内存，在于真正持有了一块连续内存的buf，go语言标准库提供的sync.Pool可以用来重用buf，可以把buf放进去，等需要时再取出实现重用内存。</p><p>因为buf持有的内存大小不同，类型不同，所以将其放进sync.Pool，需要先找到同样类型的一些sync.Pool，在从中找到同样大小的sync.Pool，以确保安全的从同一个sync.Pool，得到的是同样类型持有同样大小内存的buf。</p><p>依靠go语言标准库的sync.Map，可以高效的做到这一点<br>这是笔者写的做到上述做法的代码，其中的MemBlock和上文中的buf表示同样的含义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globarPool sync.Map</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMemBlockPool</span><span class="params">(rtype <span class="type">uintptr</span>， bufSize <span class="type">int64</span>)</span></span> *sync.Pool &#123;</span><br><span class="line">m， have := globarPool.Load(rtype)</span><br><span class="line"><span class="keyword">if</span> !have &#123;</span><br><span class="line">m = <span class="built_in">new</span>(sync.Map)</span><br><span class="line"><span class="comment">//无论是否成功，都说明同样类型的内存块的sync.Map有了</span></span><br><span class="line">m， _ = globarPool.LoadOrStore(rtype， m)</span><br><span class="line">&#125;</span><br><span class="line">typmap := m.(*sync.Map)</span><br><span class="line"><span class="comment">// 上面拿到了 每个类型不同的 sync.map , 里面有每个类型不同大小内存块的sync.Pool</span></span><br><span class="line">p， _ := typmap.Load(bufSize)</span><br><span class="line"><span class="comment">// 上面尝试拿 放着同样类型同样大小内存块的 sync.Pool</span></span><br><span class="line">blockp， have := p.(*sync.Pool)</span><br><span class="line"><span class="keyword">if</span> !have &#123;</span><br><span class="line">blockp = <span class="built_in">new</span>(sync.Pool)</span><br><span class="line">p， _ = typmap.LoadOrStore(bufSize， blockp)</span><br><span class="line"><span class="comment">// Note 这里的类型断言肯定成功，因为如果是写操作，得到的是刚刚的new(sync.Pool)，</span></span><br><span class="line"><span class="comment">// 如果是读操作，读到的是其他goroutine写的new(sync.Pool)</span></span><br><span class="line">blockp = p.(*sync.Pool)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面拿到了 放着同样类型相同大小内存块的 sync.Pool</span></span><br><span class="line"><span class="keyword">return</span> blockp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给arena一个Free方法，当这个方法被调用时，将内存池的buf放入sync.Pool。<br>然后只需要再从arena分配时，要分配的类型的内存池首先尝试从sync.Pool获取buf，就实现了重用内存。</p><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p>最终实现的arena结构如图所示<br><img src="/images/arena.png"></p><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>从arena分配一个int:</p><p>笔者实现的：8.387 ns&#x2F;op<br>go标准库的：9.299 ns&#x2F;op</p><p>从arena分配100个int再free：<br>笔者实现的：965.7 ns&#x2F;op<br>go标准库的：1079 ns&#x2F;op</p><h2 id="未来的优化"><a href="#未来的优化" class="headerlink" title="未来的优化"></a>未来的优化</h2><h3 id="定制哈希表"><a href="#定制哈希表" class="headerlink" title="定制哈希表"></a>定制哈希表</h3><p>当前，arena通过map持有不同类型的内存池，通常map的简单实现是 <code>hash(key) % len</code>，然后通用的map为了处理各种情况，有线性探测，链地址法等各种方法。在arena这个场景，这不是最优的。</p><p>针对arena的场景，key是一个指针，直接把这个指针转成整数，不需要哈希函数，直接，<code>uintptr(key) % len</code>，一条机器指令运算完成key变为index。而且因为基本查找都是成功，key的数量很少，简单的加上线性探测就可以。这样定制哈希表，可以提升性能。</p><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>分片是减少共享写操作为主的值的争用的一种有用且常用的方法。</p><p>即使只是一个原子加，在多goroutine时对性能的影响也不可小觑，根据笔者尝试实现<a href="https://github.com/golang/go/issues/18802#issuecomment-1868179680">分片</a>在go标准库的经验，同样的对int64加10000次1，如果所有的goroutine都在对同一个内存地址进行原子加，比所有的goroutine对8个不同的内存地址进行原子加，性能差了20多倍。仅仅是一个原子加，通过分片将对同一内存地址的争用分开，就有了显著的性能差异。</p><p>当前实现的热路径上还有一个原子加，通过分片，可以消除这个原子加。提升多goroutine使用arena的性能。</p><h3 id="不返回零值"><a href="#不返回零值" class="headerlink" title="不返回零值"></a>不返回零值</h3><p>go语言new一个值默认是零值，例如<code>new(int)</code>返回一个int指针，指向的int是0。<br>各种arena的实现基本也都维持了这个特性。<br>如果不需要默认零值的话，可以放弃默认零值，获得性能提升。<br>例如如果从arena分配出的内存总是马上被使用，就没有必要返回零值，可以直接将未清理的内存分配出去，稍后调用者使用会给内存赋值的。这样节省将内存设置为零值的开销</p><p>源代码地址：<a href="https://github.com/qiulaidongfeng/arena">https://github.com/qiulaidongfeng/arena</a><br>源代码地址：<a href="https://gitee.com/qiulaidongfeng/arena">https://gitee.com/qiulaidongfeng/arena</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此博客介绍笔者是如何在go标准库外实现比go标准库更好的arena。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;arena是一种内存管理方法，从中分配的内存可以被同时释</summary>
      
    
    
    
    
    <category term="go" scheme="https://qiulaidongfeng.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go语言tls1.3密码套件修改研究</title>
    <link href="https://qiulaidongfeng.github.io/zh-cn/go%E8%AF%AD%E8%A8%80tls1.3%E5%AF%86%E7%A0%81%E5%A5%97%E4%BB%B6%E4%BF%AE%E6%94%B9%E7%A0%94%E7%A9%B6/"/>
    <id>https://qiulaidongfeng.github.io/zh-cn/go%E8%AF%AD%E8%A8%80tls1.3%E5%AF%86%E7%A0%81%E5%A5%97%E4%BB%B6%E4%BF%AE%E6%94%B9%E7%A0%94%E7%A9%B6/</id>
    <published>2025-02-11T12:00:46.000Z</published>
    <updated>2025-02-11T13:16:19.383Z</updated>
    
    <content type="html"><![CDATA[<p>有些浏览器可以看到tls的一些信息，例如<br><img src="/images/s.jpg"><br>笔者看到go语言默认用的aes128,其他tls1.3实现有默认用aes256的。</p><p>go语言的tls默认tls1.3使用下列密码套件按下列顺序<br>    TLS_AES_128_GCM_SHA256,<br>    TLS_AES_256_GCM_SHA384,<br>    TLS_CHACHA20_POLY1305_SHA256<br>并且文档中明确列出TLS 1.3 ciphersuites are not configurable(TLS 1.3密码套件是不可配置的)</p><p>笔者试了类似这个程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">_ <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname defaultCipherSuitesTLS13 tls.defaultCipherSuitesTLS13</span></span><br><span class="line"><span class="keyword">var</span> defaultCipherSuitesTLS13 = []<span class="type">uint16</span>&#123;</span><br><span class="line">tls.TLS_AES_256_GCM_SHA384,</span><br><span class="line">tls.TLS_CHACHA20_POLY1305_SHA256,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := tls.Config&#123;</span><br><span class="line">MinVersion: tls.VersionTLS13,</span><br><span class="line">&#125;</span><br><span class="line">s := http.Server&#123;</span><br><span class="line">Addr:      <span class="string">&quot;:443&quot;</span>,</span><br><span class="line">TLSConfig: &amp;c,</span><br><span class="line">&#125;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">s.Handler = mux</span><br><span class="line">mux.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintln(w, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">err := s.ListenAndServeTLS(<span class="string">`cert_path`</span>, <span class="string">`key_path`</span>)</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>确实一般情况下无法配置。<br>研究确认，修改go语言tls包的defaults.go源文件中defaultCipherSuitesTLS13可以做到其他tls1.3实现的效果<br>只需将原本的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultCipherSuitesTLS13 = []<span class="type">uint16</span>&#123;</span><br><span class="line">TLS_AES_128_GCM_SHA256,</span><br><span class="line">TLS_AES_256_GCM_SHA384,</span><br><span class="line">TLS_CHACHA20_POLY1305_SHA256,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaultCipherSuitesTLS13 = []<span class="type">uint16</span>&#123;</span><br><span class="line">TLS_AES_256_GCM_SHA384,</span><br><span class="line">TLS_CHACHA20_POLY1305_SHA256,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有些浏览器可以看到tls的一些信息，例如&lt;br&gt;&lt;img src=&quot;/images/s.jpg&quot;&gt;&lt;br&gt;笔者看到go语言默认用的aes128,其他tls1.3实现有默认用aes256的。&lt;/p&gt;
&lt;p&gt;go语言的tls默认tls1.3使用下列密码套件按下列顺序&lt;br&gt;  </summary>
      
    
    
    
    
    <category term="go" scheme="https://qiulaidongfeng.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>用原子指针+互斥锁实现仅写时加锁</title>
    <link href="https://qiulaidongfeng.github.io/zh-cn/%E7%94%A8%E5%8E%9F%E5%AD%90%E6%8C%87%E9%92%88+%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E4%BB%85%E5%86%99%E6%97%B6%E5%8A%A0%E9%94%81/"/>
    <id>https://qiulaidongfeng.github.io/zh-cn/%E7%94%A8%E5%8E%9F%E5%AD%90%E6%8C%87%E9%92%88+%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E4%BB%85%E5%86%99%E6%97%B6%E5%8A%A0%E9%94%81/</id>
    <published>2024-12-17T12:00:37.000Z</published>
    <updated>2024-12-17T13:19:15.973Z</updated>
    
    <content type="html"><![CDATA[<p>此博客介绍我写<a href="https://github.com/qiulaidongfeng/arena">arena</a>的一个经验。</p><p>通常在访问共享资源时，简单的加互斥锁就够用，在读多写少时使用读写锁优化性能，在写<a href="https://github.com/qiulaidongfeng/arena">arena</a>等场景，为了极致的性能，需要别的方法。</p><h2 id="回顾一些知识，说明为什么互斥锁和读写锁不适合用在需要极致性能时。"><a href="#回顾一些知识，说明为什么互斥锁和读写锁不适合用在需要极致性能时。" class="headerlink" title="回顾一些知识，说明为什么互斥锁和读写锁不适合用在需要极致性能时。"></a>回顾一些知识，说明为什么互斥锁和读写锁不适合用在需要极致性能时。</h2><p>为什么访问共享资源时需要加锁，因为如果不加锁，多个线程可能看到正在进行操作的中间状态，并基于此中间状态执行它自己的一些操作，导致错误结果。</p><p>一个简单的例子说明这一点：</p><p>如果对变量i进行加1，CPU的执行步骤是</p><ol><li>读取i的值到寄存器</li><li>执行加1</li><li>结果写回i</li></ol><p>如果两个线程直接对变量i加1，可能的执行步骤是</p><ol><li>两个线程读取i的值（i&#x3D;1）到寄存器</li><li>执行加1,得到2</li><li>结果写回i,结果i&#x3D;2</li></ol><p>这样导致i被加了两次1但是结果却不是正确的3。</p><p>对于这种情况，CPU提供了原子操作，避免了这样因为看到其他线程操作的中间状态，导致错误结果。</p><p>CPU提供的原子操作包括原子加，原子读，原子写，原子交换等，适用于很小的数据。在一些简单的场景，如记录网站访问量，这样简单的对一个整数作加法这种场景是足够的，但在更复杂的场景不够。</p><p>对于更复杂的场景，基于原子操作产生了互斥锁。互斥锁有加锁和解锁两个操作，一把锁加锁了必须解锁才能再加锁，这样避免在更复杂的场景看到其他线程操作的中间状态。</p><p>用伪代码表示，互斥锁通常这样使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock Mutex</span><br><span class="line"></span><br><span class="line">lock.Lock()<span class="comment">//加锁</span></span><br><span class="line"><span class="comment">//复杂的操作</span></span><br><span class="line">lock.Unlock()<span class="comment">//解锁</span></span><br></pre></td></tr></table></figure><p>因为互斥锁的特性（一把锁加锁了必须解锁才能再加锁），所以可以确保复杂的操作在锁的保护中，不会被看到它操作时的中间状态，从而避免了错误结果。</p><p>简单的互斥锁用go语言写扣除空行，完整实现只需要5行代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mutex</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lock *Mutex)</span></span> Lock() &#123;<span class="keyword">for</span> !atomic.CompareAndSwapInt32((*<span class="type">int32</span>)(lock), <span class="number">0</span>, <span class="number">1</span>) &#123;&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lock *Mutex)</span></span> Unlock() &#123;<span class="keyword">for</span> !atomic.CompareAndSwapInt32((*<span class="type">int32</span>)(lock), <span class="number">1</span>, <span class="number">0</span>) &#123;&#125;&#125;</span><br></pre></td></tr></table></figure><p>很简单，就是一个整数，用原子操作，加锁就为0时改成1，解锁就为1时改成0。这样就可以实现了一个能用的互斥锁。</p><p>因为读操作与写操作不同，读操作不会改变什么，它没有中间状态，它只需要不会写操作同时进行，就可以多个线程同时进行读操作。在读多写少的场景，使用互斥锁让可以同时进行的读操作分开进行，会降低性能，所以产生了读写锁。</p><p>读写锁是这样的锁：</p><ol><li>有读锁和写锁。</li><li>不能同时加读锁没解锁和加写锁没解锁，其中一种加锁要等待另一种加锁后解锁才能。</li><li>写锁就像互斥锁。</li><li>读锁可以加锁n次，但解锁也要n次，否则加写锁永远不会成功。</li></ol><p>用伪代码表示，读写锁通常这样使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock RWMutex</span><br><span class="line"></span><br><span class="line"><span class="comment">//写操作</span></span><br><span class="line">lock.Lock()<span class="comment">//加写锁</span></span><br><span class="line"><span class="comment">//执行写操作</span></span><br><span class="line">lock.Unlock()<span class="comment">//解写锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读操作</span></span><br><span class="line">lock.RLock()<span class="comment">//加读锁</span></span><br><span class="line"><span class="comment">//执行读操作</span></span><br><span class="line">lock.RUnlock()<span class="comment">//解读锁</span></span><br></pre></td></tr></table></figure><p>这样因为读写锁的特性，所以写操作不会和读操作同时进行，多个读操作可以同时进行，比互斥锁提高了读多写少时的性能。</p><p>互斥锁和读写锁都基于原子操作实现，并且是使用原子加等相对性能更差的原子操作实现，性能随着CPU核数增加反而可能更差，所以在需要极致性能时，不适合。</p><h2 id="仅写时加锁"><a href="#仅写时加锁" class="headerlink" title="仅写时加锁"></a>仅写时加锁</h2><p>在写<a href="https://github.com/qiulaidongfeng/arena">arena</a>时，存在读多写少的场景，并且读操作特别多。每次都加读锁不能达到极致的性能。</p><p>在原子操作中，原子读相对性能更好。并且数据在内存中有内存地址，它可以进行原子读。</p><p>所以可以将使用读写锁的代码，用原子指针+互斥锁（对内存地址进行原子操作的指针）改写成这样代码：</p><p>一个伪代码展示通用的模版：</p><p>使用读写时的代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lock RWMutex</span><br><span class="line"><span class="keyword">var</span> data []<span class="type">int</span> <span class="comment">//共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写操作</span></span><br><span class="line">lock.Lock()<span class="comment">//加写锁</span></span><br><span class="line"><span class="comment">//执行写操作，例如</span></span><br><span class="line">data=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">lock.Unlock()<span class="comment">//解写锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读操作</span></span><br><span class="line">lock.RLock()<span class="comment">//加读锁</span></span><br><span class="line"><span class="comment">//执行读操作，例如</span></span><br><span class="line">v:=data[<span class="number">0</span>]</span><br><span class="line">lock.RUnlock()<span class="comment">//解读锁</span></span><br></pre></td></tr></table></figure><p>改写为用原子指针的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr atomic.Pointer[[]<span class="type">int</span>]</span><br><span class="line"><span class="keyword">var</span> lock Mutex</span><br><span class="line"><span class="keyword">var</span> data []<span class="type">int</span> <span class="comment">//共享数据</span></span><br><span class="line">ptr.Store(&amp;data)</span><br><span class="line"></span><br><span class="line"><span class="comment">//写操作</span></span><br><span class="line">lock.Lock()<span class="comment">//加写锁</span></span><br><span class="line"><span class="comment">//执行写操作，例如创建一个新的[]int替换旧的</span></span><br><span class="line"><span class="built_in">new</span>=<span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)</span><br><span class="line">ptr.Store(&amp;<span class="built_in">new</span>)</span><br><span class="line">lock.Unlock()<span class="comment">//解写锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读操作，例如读[]int</span></span><br><span class="line">v:=*ptr.Load()</span><br></pre></td></tr></table></figure><p>这样仅写时加锁，进一步提高了读操作的性能。</p><p><strong>注意采用这种办法，需要小心注意写操作的涉及的内存必须和读操作涉及的内存不相交，否则读操作和写操作可能同时对同一块内存进行，导致错误结果</strong></p><p>这是一个用伪代码写的不正确的模版：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr atomic.Pointer[[]<span class="type">int</span>]</span><br><span class="line"><span class="keyword">var</span> lock Mutex</span><br><span class="line"><span class="keyword">var</span> data []<span class="type">int</span> <span class="comment">//共享数据</span></span><br><span class="line">ptr.Store(&amp;data)</span><br><span class="line"></span><br><span class="line"><span class="comment">//写操作</span></span><br><span class="line">lock.Lock()<span class="comment">//加写锁</span></span><br><span class="line"><span class="comment">//执行写操作，例如创建一个新的[]int替换旧的</span></span><br><span class="line">v:=*ptr.Load()</span><br><span class="line">v[<span class="number">0</span>]=v[<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">lock.Unlock()<span class="comment">//解写锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读操作，例如读[]int</span></span><br><span class="line">v:=*ptr.Load()</span><br><span class="line">i:=v[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>不正确在读操作和写操作对同一块内存（v[0]）可以同时进行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;此博客介绍我写&lt;a href=&quot;https://github.com/qiulaidongfeng/arena&quot;&gt;arena&lt;/a&gt;的一个经验。&lt;/p&gt;
&lt;p&gt;通常在访问共享资源时，简单的加互斥锁就够用，在读多写少时使用读写锁优化性能，在写&lt;a href=&quot;https://</summary>
      
    
    
    
    
    <category term="go" scheme="https://qiulaidongfeng.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go1.24rc1发布</title>
    <link href="https://qiulaidongfeng.github.io/zh-cn/go1-24rc1%E5%8F%91%E5%B8%83/"/>
    <id>https://qiulaidongfeng.github.io/zh-cn/go1-24rc1%E5%8F%91%E5%B8%83/</id>
    <published>2024-12-16T14:46:29.000Z</published>
    <updated>2024-12-16T14:49:50.447Z</updated>
    
    <content type="html"><![CDATA[<p>go1.24rc1已经发布，值得注意的是</p><ul><li>抗量子密钥交换（crypto&#x2F;mlkem）</li><li>弱指针</li><li>通用哈希函数（我写的实现）</li><li>泛型类型别名</li><li>更快的终结器</li><li>CPU开销平均降低2-3%，改进包括新的map内置实现，更高效的小object内存分配，新的运行时内部互斥实现</li><li>实验性包testing&#x2F;synctest用来测试并发代码</li><li>sync.Map的新实现，提高了性能</li><li>os.Root用来在特定目录执行文件系统操作</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;go1.24rc1已经发布，值得注意的是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抗量子密钥交换（crypto&amp;#x2F;mlkem）&lt;/li&gt;
&lt;li&gt;弱指针&lt;/li&gt;
&lt;li&gt;通用哈希函数（我写的实现）&lt;/li&gt;
&lt;li&gt;泛型类型别名&lt;/li&gt;
&lt;li&gt;更快的终结器&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    
    <category term="go - go1.24" scheme="https://qiulaidongfeng.github.io/tags/go-go1-24/"/>
    
  </entry>
  
  <entry>
    <title>How does the metrics package record the number of non default behavior occurrences</title>
    <link href="https://qiulaidongfeng.github.io/en/HowDoesTheMetricsPackageRecordTheNumberOfNonDefaultBehaviorOccurrences-md/"/>
    <id>https://qiulaidongfeng.github.io/en/HowDoesTheMetricsPackageRecordTheNumberOfNonDefaultBehaviorOccurrences-md/</id>
    <published>2023-04-06T06:19:16.000Z</published>
    <updated>2023-04-06T06:34:50.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go1-21-Forward-Looking"><a href="#Go1-21-Forward-Looking" class="headerlink" title="Go1.21 Forward Looking"></a>Go1.21 Forward Looking</h1><p>Software translation</p><h2 id="How-does-the-metrics-package-record-the-number-of-non-default-behavior-occurrences"><a href="#How-does-the-metrics-package-record-the-number-of-non-default-behavior-occurrences" class="headerlink" title="How does the metrics package record the number of non default behavior occurrences"></a>How does the metrics package record the number of non default behavior occurrences</h2><p>Go1.21 is currently under development, <a href="https://tip.golang.org/doc/go1.21">draft release note</a>It is mentioned that it is expected to be released in August 2023.</p><p>In the development branch of <a href="https://github.com/golang/go">go1.21</a> In, <a href="https://pkg.go.dev/runtime/metrics@master">metrics</a>  package, a series of indicators in the format &#x2F;godebug&#x2F;non-default-behavior&#x2F;(godebug-name):events ,(godebug name) is a series of key value pairs for GODEBUG environment variables, and the names of certain keys, such as the execerrdot introduced in go1.19 (hereinafter referred to as <strong>godebug indicator</strong>). <strong>Through these newly added indicators, the number of non default behavior occurrences caused by setting these environmental variables can be obtained.</strong> This article analyzes how this is achieved by studying the source code.</p><p>Firstly, this article uses the go standard library source code (installed through gotip), with a specific version number (go version devel go1.21-8d68b388d4 Wed Apr 5 21:45:24 2023+0000 windows&#x2F;amd64).</p><hr><p>The internal&#x2F;godebug package in the Go standard library has the following APIs:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Setting <span class="keyword">struct</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(name <span class="type">string</span>)</span></span> *Setting</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Setting)</span></span> IncNonDefault()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Setting)</span></span> Name() <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Setting)</span></span> String() <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Setting)</span></span> Value() <span class="type">string</span></span><br></pre></td></tr></table></figure><p>In the Setting structure, there is a non default behavior counter of type atomic.Uint64, which is an atomic type introduced in go1.19. The API is as follows</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Uint64 <span class="keyword">struct</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Uint64)</span></span> Add(delta <span class="type">uint64</span>) (<span class="built_in">new</span> <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Uint64)</span></span> CompareAndSwap(old, <span class="built_in">new</span> <span class="type">uint64</span>) (swapped <span class="type">bool</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Uint64)</span></span> Load() <span class="type">uint64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Uint64)</span></span> Store(val <span class="type">uint64</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *Uint64)</span></span> Swap(<span class="built_in">new</span> <span class="type">uint64</span>) (old <span class="type">uint64</span>)</span><br></pre></td></tr></table></figure><p>The IncNonDefault method of this structure will atomically add 1 to the non default behavior counter every time it is called. On the first call, the Load method of the non default behavior counter will also be debugged through the runtime package’s godebug_ The registerMetric function is set to obtain the value corresponding to the godebug indicator.</p><p>By calling the IncNonDefault method every time a non default behavior occurs, the number of non default behavior occurrences can be recorded in the Setting structure.</p><p>godebug_registerMetric The signature of the function is as follows:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">godebug_registerMetric</span><span class="params">(name <span class="type">string</span>, read <span class="keyword">func</span>()</span></span> <span class="type">uint64</span>)</span><br></pre></td></tr></table></figure><p>This function sets the value of the name parameter to represent the indicator, and the function to obtain the corresponding value of the indicator as the parameter passed by the read parameter.</p><p>The ability of the metrics package to obtain the value corresponding to the godebug indicator comes from the runtime package.</p><hr><p>In this way, the order in which non default behavior occurrences are recorded and obtained is:</p><ul><li><p>Each godebug option in the go standard library is created through the New() function of the internal&#x2F;codebug package, and the return value contains non default behavior counters.</p></li><li><p>The IncNonDefault method of the Setting structure is called every time a non default behavior occurs.</p></li><li><p>The IncNonDefault method sets the function that obtains the value corresponding to the godebug indicator as the Load method of the non default behavior counter.</p></li><li><p>The IncNonDefault method Atomic plus 1 to the non default behavior counter atom.</p></li><li><p>Every time the value corresponding to the godebug indicator is obtained, the Load method of the non default behavior counter is called, which implements the phenomenon of the metrics package recording the number of non default behavior occurrences (actually recorded in the Setting structure, but the metrics package shows this phenomenon through the runtime package, which is demonstrated by calling the Load method of the non default behavior counter of the Setting structure).</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go1-21-Forward-Looking&quot;&gt;&lt;a href=&quot;#Go1-21-Forward-Looking&quot; class=&quot;headerlink&quot; title=&quot;Go1.21 Forward Looking&quot;&gt;&lt;/a&gt;Go1.21 Forward Looki</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>metrics包如何记录非默认行为发生次数</title>
    <link href="https://qiulaidongfeng.github.io/zh-cn/metrics%E5%8C%85%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95%E9%9D%9E%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%E5%8F%91%E7%94%9F%E6%AC%A1%E6%95%B0-md/"/>
    <id>https://qiulaidongfeng.github.io/zh-cn/metrics%E5%8C%85%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95%E9%9D%9E%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA%E5%8F%91%E7%94%9F%E6%AC%A1%E6%95%B0-md/</id>
    <published>2023-04-05T16:00:00.000Z</published>
    <updated>2024-12-16T15:02:37.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go1-21前瞻"><a href="#go1-21前瞻" class="headerlink" title="go1.21前瞻"></a>go1.21前瞻</h1><h2 id="metrics包如何记录非默认行为发生次数"><a href="#metrics包如何记录非默认行为发生次数" class="headerlink" title="metrics包如何记录非默认行为发生次数"></a>metrics包如何记录非默认行为发生次数</h2><p>  go1.21正在开发中，<a href="https://tip.golang.org/doc/go1.21">发行说明草案</a> 提到预计2023年8月发布。</p><p>  在go1.21的<a href="https://github.com/golang/go">开发分支</a>中，<a href="https://pkg.go.dev/runtime/metrics@master">metrics</a> 包中，新增了一系列格式如同 &#x2F;godebug&#x2F;non-default-behavior&#x2F;(godebug-name):events的指标，(godebug-name)是GODEBUG环境变量的一系列键值对，某些键的名称，比如go1.19引入的execerrdot（以下简称<strong>godebug指标</strong>）。通过这些新增的指标，可以获取<strong>因为设置了这些环境变量导致非默认行为发生次数的数量</strong>，本文通过研究源代码来分析这是如何实现的。</p><p>  首先，本文使用的是go标准库源代码(通过gotip安装)，具体版本号（go version devel go1.21-8d68b388d4 Wed Apr 5 21:45:24 2023 +0000 windows&#x2F;amd64）。</p><hr><p>  在go标准库的internal&#x2F;godebug包有如下API:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Setting <span class="keyword">struct</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(name <span class="type">string</span>)</span></span> *Setting</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(s *Setting)</span></span> IncNonDefault()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(s *Setting)</span></span> Name() <span class="type">string</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(s *Setting)</span></span> String() <span class="type">string</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(s *Setting)</span></span> Value() <span class="type">string</span></span><br></pre></td></tr></table></figure><p>在Setting结构体中，有一个非默认行为计数器，类型是atomic.Uint64，这是一个在go1.19引入的原子类型，API如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Uint64 <span class="keyword">struct</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(x *Uint64)</span></span> Add(delta <span class="type">uint64</span>) (<span class="built_in">new</span> <span class="type">uint64</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(x *Uint64)</span></span> CompareAndSwap(old, <span class="built_in">new</span> <span class="type">uint64</span>) (swapped <span class="type">bool</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(x *Uint64)</span></span> Load() <span class="type">uint64</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(x *Uint64)</span></span> Store(val <span class="type">uint64</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(x *Uint64)</span></span> Swap(<span class="built_in">new</span> <span class="type">uint64</span>) (old <span class="type">uint64</span>)</span><br></pre></td></tr></table></figure><p>这个结构体的IncNonDefault方法每次调用时非默认行为计数器都会原子加1，在第一次调用时还会将非默认行为计数器的Load方法通过runtime包的godebug_registerMetric函数设置为获取godebug指标对应的值的函数。</p><p>这样通过每次非默认行为发生时都调用IncNonDefault方法，就可以在Setting结构体中记录非默认行为发生次数。</p><p>godebug_registerMetric函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">godebug_registerMetric</span><span class="params">(name <span class="type">string</span>, read <span class="keyword">func</span>()</span></span> <span class="type">uint64</span>)</span><br></pre></td></tr></table></figure><p>这个函数将name参数的值表示的指标，获取指标对应的值的函数设置为read参数传递的参数。</p><p>metrics包获取godebug指标对应的值的能力来源于runtime包。</p><hr><p>这样，非默认行为发生次数被记录和获取的顺序是：</p><ul><li>go标准库的每个godebug选项都通过internal&#x2F;godebug包的New()函数创建，返回值包含非默认行为计数器。</li><li>每次非默认行为发生时都会调用Setting结构体的IncNonDefault方法。</li><li>IncNonDefault方法将获取godebug指标对应的值的函数设置为非默认行为计数器的Load方法。</li><li>IncNonDefault方法将非默认行为计数器原子加1。</li><li>每次godebug指标对应的值被获取，都会调用非默认行为计数器的Load方法，这样就实现了metrics包有记录非默认行为发生次数的现象（实际记录在Setting结构体，只是metrics包通过runtime包，runtime包通过调用Setting结构体的非默认行为计数器的Load方法展现出了这种现象）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;go1-21前瞻&quot;&gt;&lt;a href=&quot;#go1-21前瞻&quot; class=&quot;headerlink&quot; title=&quot;go1.21前瞻&quot;&gt;&lt;/a&gt;go1.21前瞻&lt;/h1&gt;&lt;h2 id=&quot;metrics包如何记录非默认行为发生次数&quot;&gt;&lt;a href=&quot;#metrics包</summary>
      
    
    
    
    
    <category term="go - go1.21" scheme="https://qiulaidongfeng.github.io/tags/go-go1-21/"/>
    
  </entry>
  
  <entry>
    <title>Multiplication_or_dereference</title>
    <link href="https://qiulaidongfeng.github.io/en/Multiplication-or-dereference-md/"/>
    <id>https://qiulaidongfeng.github.io/en/Multiplication-or-dereference-md/</id>
    <published>2023-03-18T16:00:00.000Z</published>
    <updated>2024-12-16T15:02:18.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Multiplication-or-dereference"><a href="#Multiplication-or-dereference" class="headerlink" title="Multiplication or dereference"></a>Multiplication or dereference</h1><p>Software translation</p><p>In the <a href="https://gitee.com/u-language/u-language">U Language Project</a> A separator based lexical analyzer is implemented in the <a href="https://gitee.com/u-language/u-language/blob/master/pkg/lex/README.md">Lexical Analyzer Design Document</a> “The current * will be parsed as a multiplication sign, and when there is no pointer, there is no problem.”. Now we are ready to add pointers to this project. If you use * to dereference as in other languages, there are two options</p><ol><li><p>When constructing an abstract syntax tree, handle ambiguity where * can be both a multiplication sign and a dereference</p></li><li><p>At the lexical analysis node, handle ambiguity where * can be both a multiplication sign and a dereference</p></li></ol><h2 id="How-to-solve-ambiguity"><a href="#How-to-solve-ambiguity" class="headerlink" title="How to solve * ambiguity"></a>How to solve * ambiguity</h2><p>When the compiler sees an ambiguity where * processing can be both a multiplication sign and a dereference, it first does not directly interpret it as a semantic method of multiplication sign or dereference. Enumeration proves that</p><ul><li><p>If it is directly interpreted as a multiplication sign, * ptr with * ptr&#x3D;1 is a dereference ptr pointer, which is now incorrectly interpreted as a multiplication ptr</p></li><li><p>If it is directly interpreted as dereference, the * b of c&#x3D;a * b is multiplied by b. It is now incorrectly interpreted as dereference b</p></li></ul><p>Therefore, it is necessary to explain * according to different situations*</p><ul><li><p>If at the beginning, because multiplication requires two operands, at the beginning, there is no operand on the left, so it can be interpreted as dereference</p></li><li><p>If it is not at the beginning, and if the * is not preceded by a symbol, such as a+* ptr, since the left side is not an operand, it can be interpreted as dereference</p></li><li><p>If it is not at the beginning, and if * is a symbol, such as a * b, because the left side is the operand, it can be interpreted as a multiplication sign</p></li></ul><p>The above processing methods can be used in lexical analysis or building an abstract syntax tree, but during lexical analysis, a Boolean variable is used to set to true when a multiplication sign is found. If the Boolean variable is true, the multiplication sign is processed using the above method. For parts without a multiplication sign, the overhead of judging is only increased once.</p><h2 id="A-simpler-approach"><a href="#A-simpler-approach" class="headerlink" title="A simpler approach"></a>A simpler approach</h2><p>If * has ambiguity, in addition to handling ambiguity, you can also find a symbol without ambiguity, such as @, and the compiler can directly identify @ as a dereference when it sees it. However, this is different from mainstream practices and may increase learning costs</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Multiplication-or-dereference&quot;&gt;&lt;a href=&quot;#Multiplication-or-dereference&quot; class=&quot;headerlink&quot; title=&quot;Multiplication or dereference&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="ulang" scheme="https://qiulaidongfeng.github.io/tags/ulang/"/>
    
  </entry>
  
  <entry>
    <title>乘法还是解引用</title>
    <link href="https://qiulaidongfeng.github.io/zh-cn/%E4%B9%98%E6%B3%95%E8%BF%98%E6%98%AF%E8%A7%A3%E5%BC%95%E7%94%A8-md/"/>
    <id>https://qiulaidongfeng.github.io/zh-cn/%E4%B9%98%E6%B3%95%E8%BF%98%E6%98%AF%E8%A7%A3%E5%BC%95%E7%94%A8-md/</id>
    <published>2023-03-18T16:00:00.000Z</published>
    <updated>2024-12-16T15:02:13.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="乘法还是解引用"><a href="#乘法还是解引用" class="headerlink" title="乘法还是解引用"></a>乘法还是解引用</h1><p>在 <a href="https://gitee.com/u-language/u-language">U语言项目</a> 中 ，实现了一个基于分隔符的词法分析器，文档在 <a href="https://gitee.com/u-language/u-language/blob/master/pkg/lex/README.md">词法分析器设计文档</a> ，当前 * 将被分析为乘号，在没有指针时，这样没有问题。现在准备给这个项目增加指针，如果按其他语言一样使用 * 解引用，有两种方案</p><ol><li><p>在构建抽象语法树时处理 * 既可以是乘号又可以解引用的二义性</p></li><li><p>在词法分析节点处理 *  既可以是乘号又可以解引用的二义性</p></li></ol><h2 id="如何解决-二义性"><a href="#如何解决-二义性" class="headerlink" title="如何解决 * 二义性"></a>如何解决 * 二义性</h2><p>当编译器看到 一个 * 处理既可以是乘号又可以解引用的二义性，首先没有直接解释为乘号或解引用一种语义的方法，枚举证明</p><ul><li>如果直接解释为 乘号 ，对于 *ptr&#x3D;1 的 *ptr是解引用ptr指针，现在被错误的解释成乘ptr</li><li>如果直接解释为 解引用 ， 对于 c &#x3D;a*b 的 *b是乘b，现在被错误的解释成解引用b</li></ul><p>所以需要根据不同情况解释 * ，对于 *</p><ul><li>如果在开头，因为乘法需要两个操作数，在开头表示左边没有操作数，所以可以解释为解引用</li><li>如果不在开头，如果 * 前面不是符号，比如 a+*ptr，因为左边不是操作数，所以可以解释为解引用</li><li>如果不在开头，如果 * 是符号，比如 a*b，因为左边是操作数，所以可以解释为乘号</li></ul><p>上述处理方法在词法分析或构建抽象语法树，都可以，但是在词法分析的时候通过一个布尔变量，在发现乘号时设置为true,在末尾判断如果布尔变量为true则按上述方法处理乘号，对于没有乘号的部分只增加一次判断的开销。</p><h2 id="更简单的办法"><a href="#更简单的办法" class="headerlink" title="更简单的办法"></a>更简单的办法</h2><p>如果* 有二义性，除了处理二义性还可以找一个没有二义性的符号，比如@，然后编译器看到@就可以直接的识别为解引用，只不过这样和主流做法有区别，可能增加学习成本</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;乘法还是解引用&quot;&gt;&lt;a href=&quot;#乘法还是解引用&quot; class=&quot;headerlink&quot; title=&quot;乘法还是解引用&quot;&gt;&lt;/a&gt;乘法还是解引用&lt;/h1&gt;&lt;p&gt;在 &lt;a href=&quot;https://gitee.com/u-language/u-language</summary>
      
    
    
    
    
    <category term="ulang" scheme="https://qiulaidongfeng.github.io/tags/ulang/"/>
    
  </entry>
  
  <entry>
    <title>mmap_error</title>
    <link href="https://qiulaidongfeng.github.io/en/mmap-error/"/>
    <id>https://qiulaidongfeng.github.io/en/mmap-error/</id>
    <published>2023-03-02T13:00:49.000Z</published>
    <updated>2023-03-02T13:06:23.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go1-21-forward-looking"><a href="#Go1-21-forward-looking" class="headerlink" title="Go1.21 forward-looking"></a>Go1.21 forward-looking</h1><p>Software translation</p><h2 id="Windows-allows-handling-exception-page-errors"><a href="#Windows-allows-handling-exception-page-errors" class="headerlink" title="Windows allows handling exception page errors"></a>Windows allows handling exception page errors</h2><p>Go1.21 is under development, <a href="https://tip.golang.org/doc/go1.21">draft release note</a> Mention that it is expected to be released in August 2023</p><p>According to the submitted information <a href="https://github.com/golang/go/commit/e03ee85ef434f307500a71927dfb3e876161847a">runtime: Allow handling of EXCEPTION_IN_PAGE_ERROR</a> Go1.21 allows you to handle the access failure of the memory-mapped file through debug.SetPanicOnFault in Windows (for example, the drive where the memory-mapped file is located is ejected)</p><p>For example, it comes from <a href="https://github.com/golang/go/issues/58457">golang&#x2F;go#58457</a> Example of</p><p>Memory mapping files on external disks (using CreateFileMapping&#x2F;MapViewOfFile)<br>Call debug. SetPanicOnFault (true)<br>Eject external disk<br>Attempt to read from memory map<br>What do you see?<br>The runtime faults (Exception 0xc0000006 0x0 …)</p><p>This is not a panic and cannot be recovered through recover</p><p>Go1.21 should be the panic</p><p>According to <a href="https://pkg.go.dev/runtime/debug#SetPanicOnFault">SetPanicOnFault document</a> In this case, when debugging. SetPanicOnFault (true) is called, a program using a memory mapping file or an unsafe memory operation may cause a non-zero address error; SetPanicOnFault allows such a program to request to trigger panic only once when running. According to <a href="https://github.com/golang/go/issues/58457">golang&#x2F;go#58457</a> At least that was not the case in go1.19. As of the release, we did not see that the official go plans to reverse migrate the repair submission to the next minor version of go1.20 and go1.19</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go1-21-forward-looking&quot;&gt;&lt;a href=&quot;#Go1-21-forward-looking&quot; class=&quot;headerlink&quot; title=&quot;Go1.21 forward-looking&quot;&gt;&lt;/a&gt;Go1.21 forward-looki</summary>
      
    
    
    
    
    <category term="go - go1.21" scheme="https://qiulaidongfeng.github.io/tags/go-go1-21/"/>
    
  </entry>
  
  <entry>
    <title>mmap错误</title>
    <link href="https://qiulaidongfeng.github.io/zh-cn/mmap%E9%94%99%E8%AF%AF/"/>
    <id>https://qiulaidongfeng.github.io/zh-cn/mmap%E9%94%99%E8%AF%AF/</id>
    <published>2023-03-01T16:00:00.000Z</published>
    <updated>2024-12-16T15:01:49.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go1-21前瞻"><a href="#go1-21前瞻" class="headerlink" title="go1.21前瞻"></a>go1.21前瞻</h1><h2 id="windows允许处理异常页面错误"><a href="#windows允许处理异常页面错误" class="headerlink" title="windows允许处理异常页面错误"></a>windows允许处理异常页面错误</h2><p>go1.21正在开发中，<a href="https://tip.golang.org/doc/go1.21">发行说明草案</a> 提到预计2023年8月发布</p><p>根据提交信息 <a href="https://github.com/golang/go/commit/e03ee85ef434f307500a71927dfb3e876161847a">runtime: Allow handling of EXCEPTION_IN_PAGE_ERROR</a> go1.21允许在windows通过debug.SetPanicOnFault 处理内存映射文件的访问故障（例如，内存映射文件所在的驱动器被弹出）</p><p>例如来源于 <a href="https://github.com/golang/go/issues/58457">golang&#x2F;go#58457</a>的例子<br>内存映射外部磁盘上的文件(使用CreateFileMapping &#x2F; MapViewOfFile)<br>调用debug.SetPanicOnFault(true)<br>弹出外部磁盘<br>尝试从内存映射中读取</p><p>看到的是？<br>The runtime faults (Exception 0xc0000006 0x0 …)<br>这不是panic,不能通过recover恢复</p><p>go1.21应该是看到的 panic …</p><p>根据 <a href="https://pkg.go.dev/runtime/debug#SetPanicOnFault">SetPanicOnFault文档</a>这种情况当 调用debug.SetPanicOnFault(true) 后使用内存映射文件的程序或不安全的内存操作可能会导致非零地址出错；SetPanicOnFault允许这样的程序请求运行时只触发一次panic，根据<a href="https://github.com/golang/go/issues/58457">golang&#x2F;go#58457</a> 至少在go1.19不是这样，截至发布前，没看到go官方打算将修复的提交反向移植到go1.20和go1.19的下一个次要版本</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;go1-21前瞻&quot;&gt;&lt;a href=&quot;#go1-21前瞻&quot; class=&quot;headerlink&quot; title=&quot;go1.21前瞻&quot;&gt;&lt;/a&gt;go1.21前瞻&lt;/h1&gt;&lt;h2 id=&quot;windows允许处理异常页面错误&quot;&gt;&lt;a href=&quot;#windows允许处理异</summary>
      
    
    
    
    
    <category term="go - go1.21" scheme="https://qiulaidongfeng.github.io/tags/go-go1-21/"/>
    
  </entry>
  
  <entry>
    <title>First blog</title>
    <link href="https://qiulaidongfeng.github.io/en/one/"/>
    <id>https://qiulaidongfeng.github.io/en/one/</id>
    <published>2023-02-28T16:00:00.000Z</published>
    <updated>2024-12-16T15:01:25.907Z</updated>
    
    <content type="html"><![CDATA[<p>Software translation<br>On March 1, 2023, I published this blog</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Software translation&lt;br&gt;On March 1, 2023, I published this blog&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第一个博客</title>
    <link href="https://qiulaidongfeng.github.io/zh-cn/one/"/>
    <id>https://qiulaidongfeng.github.io/zh-cn/one/</id>
    <published>2023-02-28T16:00:00.000Z</published>
    <updated>2024-12-16T15:01:00.937Z</updated>
    
    <content type="html"><![CDATA[<p>2023年3月1日，我公开了这个博客</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2023年3月1日，我公开了这个博客&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
